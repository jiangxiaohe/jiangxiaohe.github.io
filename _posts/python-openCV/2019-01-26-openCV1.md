---
layout: post
title: OpenCV图像基本操作
tags:
- openCV
categories: python-openCV
description: openCV学习过程
---
# 参考
[《OpenCV 3计算机视觉：Python语言实现（原书第2版）》](https://blog.csdn.net/wyx100/article/details/73006307)

[网易云课堂](https://study.163.com/course/courseMain.htm?courseId=1208943817)


# 安装方法
直接使用pip命令安装即可
`pip install opencv-python`

如果速度较慢，请使用-i标签指定下载源`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python`

openCV开发需要用到三个包`numpy matplotlib opencv-python opencv-contrib-python`

# 测试程序

```python
#导入cv模块
import cv2 as cv
#读取图像，支持 bmp、jpg、png、tiff 等常用格式
# opencv默认的格式是RGB
img = cv.imread("D:\opencv\lena.jpg")
#创建窗口并显示图像
cv.namedWindow("Image")
cv.imshow("Image",img)
#esc退出
cv.waitKey(0)
#释放窗口
cv2.destroyAllWindows()
```

# 图像IO

`cv2.imread(filename[,flag])`
flag有三种取值：
* cv2.IMREAD_COLOR : 彩色图
* cv2.IMREAD_GRAYSCALE : 灰度图
* cv2.IMREAD_UNCHANGED : Loads image as such including alpha channel


>可以用 1, 0 or -1 来代替这三个取值.

`cv2.write(filename,img[,params])`
默认以PNG保存。例如`cv2.imwrite('mycat.png',img)`

`cv2.imshow(name,img)`

# 截取部分图像数据

```python
img=cv2.imread('cat.jpg')
cat=img[0:50,0:200]
cv_show('cat',cat)
```

# 颜色通道提取与合并

```python
(B,R,R)=cv2.split(img)
dst=cv2.merge([B,G,R])
# 只保留R
cur_img = img.copy()
cur_img[:,:,0] = 0
cur_img[:,:,1] = 0
cv_show('R',cur_img)
```

# 边界填充
```python
top_size,bottom_size,left_size,right_size = (50,50,50,50)
#该参数的定义为上下左右分别扩展的像素的个数

replicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)
reflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size,cv2.BORDER_REFLECT)
reflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT_101)
wrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_WRAP)
constant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size,cv2.BORDER_CONSTANT, value=0)

import matplotlib.pyplot as plt
plt.subplot(231), plt.imshow(img, 'gray'), plt.title('ORIGINAL')
plt.subplot(232), plt.imshow(replicate, 'gray'), plt.title('REPLICATE')
plt.subplot(233), plt.imshow(reflect, 'gray'), plt.title('REFLECT')
plt.subplot(234), plt.imshow(reflect101, 'gray'), plt.title('REFLECT_101')
plt.subplot(235), plt.imshow(wrap, 'gray'), plt.title('WRAP')
plt.subplot(236), plt.imshow(constant, 'gray'), plt.title('CONSTANT')

plt.show()
```

- BORDER_REPLICATE：复制法，也就是复制最边缘像素。
- BORDER_REFLECT：反射法，对感兴趣的图像中的像素在两边进行复制例如：fedcba|abcdefgh|hgfedcb   
- BORDER_REFLECT_101：反射法，也就是以最边缘像素为轴，对称，gfedcb|abcdefgh|gfedcba
- BORDER_WRAP：外包装法cdefgh|abcdefgh|abcdefg  
- BORDER_CONSTANT：常量法，常数值填充。

# 图像融合

`res = cv2.addWeighted(img_cat, 0.4, img_dog, 0.6, 0)`
注意，融合的两张图片的shape应该相同，采用`resize`函数而非`reshape`

* reshape:只是在逻辑上改变矩阵的行列数或者通道数，没有任何的数据的复制，也不会增减任何数据，因此这是一个O(1)的操作，它要求矩阵是连续的。
* resize:对图像进行压缩扩大处理。

# 视频IO

* cv2.VideoCapture可以捕获摄像头，用数字来控制不同的设备，例如0,1。
* 如果是视频文件，直接指定好路径即可。

```python
vc = cv2.VideoCapture('test.mp4')
# 检查是否打开正确
if vc.isOpened():
    open, frame = vc.read()
else:
    open = False
while open:
    ret, frame = vc.read()
    if frame is None:
        break
    if ret == True:
        gray = cv2.cvtColor(frame,  cv2.COLOR_BGR2GRAY)
        cv2.imshow('result', gray)
        if cv2.waitKey(100) & 0xFF == 27:
            break
vc.release()
cv2.destroyAllWindows()
```
