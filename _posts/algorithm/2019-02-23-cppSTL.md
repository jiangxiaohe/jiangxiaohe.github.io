---
layout: post
title: C++STL总结
tags:
- DSA
categories: algorithm
description: 在学堂在线DSA课程的基础上，实现C++的典型STL
---

# Vector

```cpp
#ifndef VECTOR_H
#define VECTOR_H

#define CAPACITY 10
#define Rank int
template<typename T>
class Vector {
protected:
	int _capacity;
	int _size;
public:
	T* _elem;
	//构造与析构
	Vector(int ncapacity = CAPACITY) { _capacity = ncapacity; _size = 0; _elem = new T[_capacity]; }//注意这里是[]，而不是小括号

	void copyFrom(T* A, Rank lo, Rank hi) {
		_elem = new T[(hi - lo) << 1]; _size = 0; while (lo < hi)_elem[_size++] = A[lo++];
	}

	Vector(T* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); }

	Vector<T>& operator=(Vector<T> const& b) {//整体复制
		if (_elem)delete[] _elem;
		copyFrom(b._elem, 0, b.size());
		return *this;
	}

	~Vector() { delete[]  _elem; }

	void expand() {
		if (_size == _capacity) {
			T* tmp = _elem; _capacity = _capacity << 1; _elem = new T[_capacity];
			for (int i = 0; i < _size; i++)_elem[i] = tmp[i];
			delete[] tmp;
		}
	}

	void shrink() {
		if (_size >= _capacity >> 2)return;//以25%为界
		T* tmp = _elem; _elem = new T[_capacity >>= 1];
		for (int i = 0; i < _size; i++)_elem[i] = tmp[i];
		delete[] tmp;
	}

	int size() { return _size; }

	bool empty() { return _size == 0; }

	T& operator[](Rank i) { return _elem[i]; }

	void push_back(T t) { expand(); _elem[_size++] = t; }

	T pop_back() { T t = _elem[--_size]; shrink(); return t; }

	//遍历，使用函数对象
	template<typename VST>
	void traverse(VST& visit) {
		for (Rank i = 0; i < _size; i++)visit(_elem[i]);
	}

	Rank insert(Rank r, const T& e) {
		expand(); _size++;
		for (int i = _size; i > r; i--)_elem[i] = _elem[i - 1];
		_elem[r] = e;
		return r;
	}

	//删除[lo,hi)区间内的节点
	int remove(Rank lo, Rank hi) {
		if (lo >= hi)return 0;
		while (hi < _size)_elem[lo++] = _elem[hi++];
		_size = lo;
		shrink();
		return hi - lo;
	}

	//删除单个节点
	T remove(Rank r) { T e = _elem[r]; remove(r, r + 1); return e; }

	//无序向量中找最大值
	Rank findmax(Rank lo, Rank hi) {
		Rank max = lo;
		for (Rank i = lo; i < hi; i++)
			if (_elem[i] > _elem[max])max = i;
		return max;
	}

	//无序向量的顺序查找，找到返回秩，找不到返回-1
	Rank find(const T& e, Rank lo, Rank hi) {
		Rank i;
		for (i = lo; i < hi; i++)if (_elem[i] == e)break;//假设hi位置是一个无穷大哨兵
		return (i == hi ? -1 : i);
	}

	Rank find(const T& e) { return find(e, 0, _size); }

	//search表示更高级的查找算法，如二分，find表示顺序查找
	Rank search(const T& e, Rank lo, Rank hi) {//二分查找[lo,hi)
		int mi;
		while (lo < hi) {
			mi = (lo + hi) >> 1;
			if (_elem[mi] <= e)lo = mi + 1;
			else hi = mi;
		}
		return lo - 1;
	}

	Rank search(const T& e) { return search(e, 0, _size); }

	bool operator<(Vector<T> b) {
		int i = 0;
		while (i < _size&&i < b.size()) {
			if (_elem[i] < b[i])return true;
			else if (_elem[i] == b[i])i++;
			else return false;
		}
		if (i == _size)return true;
		if (i = b.size())return false;
	}

	//排序算法
	void bubbleSort(Rank lo, Rank hi);
	void selectionSort(Rank lo, Rank hi);
	void insertSort(Rank lo, Rank hi);
	void merge(Rank lo, Rank mi, Rank hi);
	void mergeSort(Rank lo, Rank hi);
	//void heapSort(Rank lo, Rank hi);
	void quickSort(Rank lo, Rank hi);

	//重载默认排序算法，不能用bubbleSort(Rank lo=0,Rank hi=_size)
	//因为类中非静态成员变量不能作为默认参数，应采用这种重载的方式
	void bubbleSort();
	void selectionSort();
	void insertSort();
	void mergeSort();
	//void heapSort();
	void quickSort();
};

template<typename T>
void Vector<T>::bubbleSort(Rank lo, Rank hi) {
	bool sorted = false;
	int last = hi;
	while (!sorted) {
		sorted = true;
		hi = last;
		for (Rank i = lo; i < hi - 1; i++) {
			if (_elem[i] > _elem[i + 1]) { sorted = false; swap(_elem[i], _elem[i + 1]); last = i + 1; }
		}
	}
}
template<typename T>
void Vector<T>::bubbleSort() { bubbleSort(0, _size); }

template<typename T>
void Vector<T>::selectionSort(Rank lo, Rank hi) {
	Rank max;
	while (lo < hi) {
		swap(_elem[findmax(lo, hi)], _elem[hi - 1]); hi--;
	}
}
template<typename T>
void Vector<T>::selectionSort() { selectionSort(0, _size); }

template<typename T>
void Vector<T>::insertSort(Rank lo, Rank hi) {
	for (Rank i = lo + 1; i < hi; i++) {
		T t = _elem[i];
		Rank j = i;
		while (_elem[--j] > t)_elem[j + 1] = _elem[j];
		_elem[j + 1] = t;
	}
}
template<typename T>
void Vector<T>::insertSort() { insertSort(0, _size); }

template<typename T>
void Vector<T>::merge(Rank lo, Rank mi, Rank hi) {//原序列、左部分、有部分分别用abc表示
	int lb = mi - lo, lc = hi - mi;
	T* tmp = new T[lb];
	for (int i = 0; i < lb; i++)tmp[i] = _elem[lo + i];
	Rank i = lo, j = 0, k = mi;
	/*改进前判断的条件有三个
	while(i<hi){//注意这里添加尾部无穷大哨兵的做法
		while(j<lb&&(k==hi||tmp[j]<=_elem[k]))_elem[i++]=tmp[j++];
		while(k<hi&&(j==lb||tmp[j]>_elem[k]))_elem[i++]=_elem[k++];
	}*/
	/*改进后，注意内部两个while的顺序，j++的执行应放在最后。而且，第二句不能用while，应为内部while的入口没有判断j是否越界。
	while(j<lb){
		while(k<hi&&tmp[j]>_elem[k])_elem[i++]=_elem[k++];
		if(k>=hi||tmp[j]<=_elem[k])_elem[i++]=tmp[j++];

	}*/
	//上述版本虽然简洁，但是不易维护。如下代码虽然增加了一行，但是易维护、易理解
	while (j < lb&&k < hi) {
		while (j < lb&&tmp[j] <= _elem[k])_elem[i++] = tmp[j++];
		while (k<hi&&tmp[j]>_elem[k])_elem[i++] = _elem[k++];
	}
	while (j < lb)_elem[i++] = tmp[j++];
	delete[] tmp;
}
template<typename T>
void Vector<T>::mergeSort(Rank lo, Rank hi) {
	if (lo >= hi - 1)return;
	int mi = (lo + hi) >> 1;
	mergeSort(lo, mi);
	mergeSort(mi, hi);
	if (_elem[mi - 1] > _elem[mi])merge(lo, mi, hi);//加入这一句判断，减少不必要的merge操作
}
template<typename T>
void Vector<T>::mergeSort() { mergeSort(0, _size); }

//快排
/*就地重拍算法可以有三种
	方法一：阿哈算法，中间元素先完成全部交换，最后再与首元素交换，注意把左侧元素当做标记元素的时候，先从右向左找:初始化i=lo+1,j=hi,首先j向左找比标记位小的元素，i向右找比标记位大的元素，然后将两者交换，不断重复这个过程，直到两者相等，i=j时可以判断，[lo+1,i]均比标记小，(i,hi]均比标记大，最后，再交换下lo,i即可。
	方法二：邓老师书中采用的是两边比较，不断变换空闲位置，把最左侧元素放到接近的位置，最后把第一个元素的复制放在最后一个空闲位置。
	方法三：《算法导论》
*/

//方法一：阿哈算法，中间交换，最后把lo换到中间
int partition(vector<int>& vec,int lo,int hi){//[lo,hi]上层调用函数保证了lo<hi
	swap(vec[lo],vec[rand()%(hi-lo+1)+lo]);
	int i=lo,j=hi;//注意这里一定从lo出发，这样可以保证lo是最小元素的情况
	while(i<j){
		while(i<j&&vec[j]>=vec[lo])j--;
		while(i<j&&vec[i]<=vec[lo])i++;
		swap(vec[i],vec[j]);
	}
	swap(vec[lo],vec[i]);//这里交换一定要发生才能把lo元素放到中间来
	//cout<<"lo="<<lo<<"  hi="<<hi<<"  i="<<i<<endl;printvec(vec);
	return i;
}

//方法二：邓老师版本，两边不停的向中间扫描

//版本A，勤于拓展，懒于交换
int partitionA(vector<int>& vec,int lo,int hi){//语义规定：对[lo,hi]两头闭区间进行就地重拍
    swap(vec[lo],vec[rand()%(hi-lo+1)+lo]);
	int tmp=vec[lo];
    while(lo<hi){
        while(lo<hi&&tmp<=vec[hi])hi--;//向左扩展右端子序列
        vec[lo]=vec[hi];
        while(lo<hi&&tmp>=vec[lo])lo++;//向右扩展
        vec[hi]=vec[lo];
    }
	vec[lo]=tmp;
	return lo;
}
//版本B：勤于交换，懒于拓展
int partitionB(vector<int>& vec,int lo,int hi){//语义规定：对[lo,hi]两头闭区间进行就地重拍
    swap(vec[lo],vec[rand()%(hi-lo+1)+lo]);
	int tmp=vec[lo];
    while(lo<hi){
        while(lo<hi&&tmp<vec[hi])hi--;//向左扩展右端子序列
        if(lo==hi)break;
		vec[lo++]=vec[hi];
        while(lo<hi&&tmp>vec[lo])lo++;//向右扩展
		if(lo==hi)break;
        vec[hi--]=vec[lo];
    }
	vec[lo]=tmp;
	return lo;
}

/*方法三：算法导论版本，将最后一个元素放入其应该的位置,[lo,hi]是待排序序列，(i,j)表示比vec[lo]大的元素的集合，从左向右扩展，初始化i=lo-1，j=lo，表示没有元素，然后j向右探索
    遇到的元素比hi元素小，如果i,j中间没有元素，就i++,j++,表示跳过该元素，如果i，j之间有元素，就交换(i+1,j),然后i++,j++
    当j遇到hi时,退出循环，交换(i+1,j)即可
    找到比lo小的元素就交换(i,j-1)，然后j--，就继续满足[i,j)比vec[lo]小。当i=lo时退出循环，交换(i,j-1)，返回j-1
*/
int partition(vector<int>& vec,int lo,int hi){
    swap(vec[lo],vec[rand()%(hi-lo+1)+lo]);
	int i=lo-1,j=lo;
    while(j<hi){
        while(j<hi&&vec[j]>=vec[hi])j++;
        if(j==hi)break;
        if(i+1<j)swap(vec[i+1],vec[j]);
        j++;i++;
    }
    swap(vec[i+1],vec[hi]);
	return i+1;
}

template<typename T>
void Vector<T>::quickSort(Rank lo, Rank hi){
	if(lo>=hi-1)return;
	int mi=partition(lo,hi-1);
	quicksort(lo,mi);
	quicksort(mi+1,hi);
}
template<typename T>
void Vector<T>::quickSort() { quickSort(0, _size); }

#endif
```

# List

```cpp
#ifndef LIST_H
#define LIST_H

#define Rank int
#define NULL 0

template<typename T>
struct ListNode {
public:
	ListNode<T>* pred;
	ListNode<T>* succ;
	T data;
	ListNode() {};
	ListNode(T e, ListNode<T>* p = NULL, ListNode<T>* s = NULL) :data(e), pred(p), succ(s) {}

	ListNode<T>* insertAsPred(T t) {
		ListNode<T>* tmp = new ListNode<T>(t);
		tmp->pred = pred; tmp->succ = this; pred->succ = tmp; pred = tmp;
		return tmp;
	}

	ListNode<T>* insertAsSucc(T t) {
		ListNode<T>* tmp = new ListNode<T>(t);
		tmp->pred = this; tmp->succ = succ; succ->pred = tmp; succ = tmp;
		return tmp;
	}
};

template<typename T>
class List {
	int _size;
	ListNode<T>* header;
	ListNode<T>* tailer;
public:
	int size() { return _size; }
	bool empty() { return _size == 0; }
	ListNode<T>* const front() { return header->succ; }
	ListNode<T>* const back() { return tailer->pred; }

	void init() {
		header = new ListNode<T>;
		tailer = new ListNode<T>;
		header->succ = tailer; header->pred = NULL;
		tailer->pred = header; tailer->succ = NULL;
		_size = 0;
	}

	void copyNode(ListNode<T>* p, int n) {
		init();
		while (n--) { insertAsLast(p->data); p = p->succ; }
	}

	List() { init(); }

	List(ListNode<T>* p, int n) { copyNode(p, n); }

	List(List<T> const& L) { copyNode(L.first(), L.size()) }

	//复制L中自r起的n项
	List(List<T> const& L, int r, int n) { copyNode(L[r], n); }

	//清空所有节点
	~List() { delete header; delete tailer; }
	int clear() {}

	//插入操作
	ListNode<T>* insertBefore(ListNode<T>* p, T t) { _size++; return p->insertAsPred(t); }
	ListNode<T>* insertAfter(ListNode<T>* p, T t) { _size++; return p->insertAsSucc(t); }
	ListNode<T>* insertAsFirst(T t) { _size++; return header->insertAsSucc(t); }
	ListNode<T>* insertAsLast(T t) { _size++; return tailer->insertAsPred(t); }
	ListNode<T>* push_back(T t) { return insertAsLast(t); }

	//删除，假定T类型可以直接复制，返回其值
	T remove(ListNode<T>* p) {
		T t = p->data; _size--;
		p->succ->pred = p->pred; p->pred->succ = p->succ;
		delete p;
		return t;
	}
	T removeAtFirst() { return remove(header->succ); };

	//寻秩访问，效率很低,注意这里返回值为引用
	T& operator[](Rank i) {
		ListNode<T>* tmp = header;
		while (i-- >= 0)tmp = tmp->succ;
		return tmp->data;
	}

	//遍历
	template<typename VST>
	void traverse(VST& visit) {
		for (ListNode<T>* p = header->succ; p != tailer; p = p->succ)visit(p->data);
	}

	//查找，与向量一样，无论成功与否，都要便于后续插入等操作的实现
	//在p的n个真前驱中，查找元素e
	ListNode<T>* search(T& e, ListNode<T>* p, int n) {
		while (0 <= n--)//这里的循环是n+1次，最后n=0的时候，比较毫无意义，只是为了定位到要返回的节点，即p的n+1个真前驱
			if ((p = p->pred)->data <= e)break;
		return p;
	}

	//排序
	void merge(ListNode<T>*&, int, List<T>&, ListNode<T>*&, int);
	void mergeSort(ListNode<T>*&, int);
	void selectionSort(ListNode<T>, int);
	void insertSort(ListNode<T>, int);
};
#endif
```

# Stack

```cpp
#ifndef STACK_H
#define STACK_H

#include"Vector.h"
#include<iostream>
using namespace std;

template<typename T>
class Stack :public Vector<T> {
public:
	//注意派生类的构造函数写法，成员对象名的个数与顺序
	Stack(int _capacity = CAPACITY) :Vector<T>(_capacity) {}
	//~Stack(){}
	void push(const T e) { push_back(e); }
	T pop() { return pop_back(); }
	T top() { return (*this)[size() - 1]; }
};

//进制转换，这里用栈实现数值转化的算法是非常简单的
void convert(Stack<char>& s, long long n, int base) {
	static char digit[] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };
	while (n != 0) {
		s.push(digit[(int)(n%base)]);
		n = n / base;
	}
	while (!s.empty())cout << s.pop();
}

//重要：判断一个排列(0-n)是不是栈混洗
bool isStackMixing(Vector<int>& vec) {//这里的参数应该是引用
	Stack<int> s;
	int i = 0;//[0,n)的队列
	int j = 0;//vec参数的秩
	while (i < vec.size()) {//循环，反复入栈出栈
		s.push(i++);
		while (!s.empty() && s.top() == vec[j]) {
			j++;
			s.pop();
		}
	}
	return s.empty();
}

//括号匹配，代码编译过程的重要一环，先写只有()的情况，再写加入了[]{}的情况
bool paren(const char exp[], int lo, int hi) {
	Stack<char> s;
	for (int i = lo; i < hi; i++) {
		switch (exp[i]) {
		case '(':case '[':case '{':s.push(exp[i]); break;
		case ')':if (s.empty() || s.pop() != '(')return false; break;
		case ']':if (s.empty() || s.pop() != '[')return false; break;
		case '}':if (s.empty() || s.pop() != '{')return false; break;
		default:break;
		}
	}
	return s.empty();
}

//逆波兰表达式RPN计算
//先建立不同运算符的优先关系
#define N_OPER 9
typedef enum { ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE } Operator;
const char pri[N_OPER][N_OPER] = {//这里要搞清楚点，优先级关系如何定义，对括号如何处理
				/*         当前运算符                   */
				/*  +   -   *   /   ^   !   (   )   \0 */
	/*	    + */   '>','>','<','<','<','<','<','>','>',
	/*	    - */   '>','>','<','<','<','<','<','>','>',
	/*	之  * */   '>','>','>','>','<','<','<','>','>',
	/*	前  / */   '>','>','>','>','<','<','<','>','>',
	/*	运  ^ */   '>','>','>','>','>','<','<','>','>',
	/*	算  ! */   '>','>','>','>','>','>',' ','>','>',
	/*	符  ( */   '<','<','<','<','<','<','<','=',' ',
	/*	    ) */   ' ',' ',' ',' ',' ',' ',' ',' ',' ',
	/*	    \0*/   '<','<','<','<','<','<','<',' ','='
	//注意，这一行对应头部哨兵的情况，简化控制流程边界情况的处理，最后这个等号，是建立头哨兵\0，以便处理结尾的情况
};

//读取从i开始的操作数,tRPN指RPN当前的指针
int readnum(char*& S, char*& tRPN) {
	int tmp = 0;
	while (*S != '\0' && *S >= '0'&&*S <= '9') {
		tmp = tmp * 10 + *S - '0';
		*(tRPN++) = *S;
		S++;
	}
	*(tRPN++) = ' ';
	return tmp;
}

//计算RPN表达式
int readnum(char*& S) {
	int tmp = 0;
	while (*S != '\0' && *S >= '0' && *S <= '9') {
		tmp = tmp * 10 + *S - '0';
		S++;
	}
	return tmp;
}

//比较两个操作的优先级
char orderbetween(char oper1, char oper2) {
	Operator a[2];
	char c[2] = { oper1,oper2 };
	for (int i = 0; i < 2; i++) {
		switch (c[i]) {
		case'+':a[i] = ADD; break;
		case'-':a[i] = SUB; break;
		case'*':a[i] = MUL; break;
		case'/':a[i] = DIV; break;
		case'^':a[i] = POW; break;
		case'!':a[i] = FAC; break;
		case'(':a[i] = L_P; break;
		case')':a[i] = R_P; break;
		case'\0':a[i] = EOE; break;
		}
	}
	return pri[a[0]][a[1]];
}

//实现表达式求值算法，对已剔除白空格的表达式S求值，并转换为RPN表达式
float evaluate(char* S, char*& RPN) {
	char* tRPN = RPN;//tRPN表示RPN当前的指针,谨记，RPN的顺序使出栈计算的顺序而非入栈的顺序
	Stack<int> numStack;
	Stack<char> operStack;
	int opernum1, opernum2;
	char opertmp, oper;
	operStack.push('\0');

	while (!operStack.empty()) {
		if (*S >= '0'&&*S <= '9') {
			opernum1 = readnum(S, tRPN); numStack.push(opernum1);
		}else{
			//注意这里对不同优先级的处理策略
			//尤其是栈顶优先级较高的情况，取操作数计算而不入栈
			//当前优先级较高时，入栈而接收下一个字符
			opertmp = *S;
			switch (orderbetween(operStack.top(), opertmp)) {
			case'>'://栈顶元素优先级更高，需取出操作数计算，然后结果重新入栈，当前运算符不变
				opernum1 = numStack.pop(); oper = operStack.pop();
				*(tRPN++) = oper;//*(tRPN++)=' ';此处不加空格，此处需要与RPN计算的算法相互配合
				if (oper != '!') {//双目运算符取两个操作数
					opernum2 = numStack.pop();
					numStack.push(fun(opernum1, opernum2, oper));
				}
				else {//单目运算符取一个操作符即可
					numStack.push(fac(opernum1));
				}
				break;
			case'<'://当前运算符优先级更高时，直接将当前运算符入栈，并接收下一个字符
				operStack.push(opertmp); S++;
				break;
			case'='://两者优先级相等时，去除括号，并接收下一个字符
				operStack.pop(); S++;
				break;
			default:exit(-1);//语法错误，暂不做处理
			}
		}
	}
	*tRPN = '\0';
	return numStack.pop();
}

//计算RPN表达式的值
float rpnEvaluation(char* S) {
	Stack<float> numStack;
	int opernum1, opernum2;
	char oper;
	while (*S != '\0') {
		if (*S >= '0'&&*S <= '9') {
			numStack.push(readnum(S));
			S++;//跳过空格
		}else if (*S == '!') {
			opernum1 = numStack.pop();
			numStack.push(fac(opernum1));
			S++;
			//到下一个运算符，注意这里的操作是和RPN的生成相互配合的，RPN生成算法中，每个数字后面补充一个空格，故读取数字时要跳过空格，而运算符后没有空格，故不用跳过空格。
		}else {
			opernum1 = numStack.pop();
			opernum2 = numStack.pop();
			numStack.push(fun(opernum1, opernum2, *S));
			S++;//到下一个运算符
		}
	}
	return numStack.pop();
}

//试探回溯法解八皇后问题
struct Queen {
	int x, y;
	Queen(int xx = 0, int yy = 0) :x(xx), y(yy) {}
	bool operator==(Queen b) {
		return x == b.x || y == b.y || x + y == b.x + b.y || x - y == b.x - b.y;
	}
};

void placeQueens(int N) {
	Stack<Queen> solu;
	int nsolu = 0, ncheck = 0;
	Queen q(0, 0);
	solu.push(q);
	//不断的试探回溯,忒休斯的绳索是栈，入栈是进一步，出栈是退一步
	while (0 < q.x || q.y < N) {
		//这是书中的答案
		if(N<=solu.size()||N<=q.y){//若已经出界，则回溯一行
			q=solu.pop();q.y++;
		}else{//没有出界时，试探下一行
			while((q.y<N)&&(0<=solu.find(q))){
				q.y++;ncheck++;
			}
			if(N>q.y){
				solu.push(q);
				if(N<=solu.size())nsolu++;
				q.x++;q.y=0;//转入下一行
			}
		}
	}
}
/*测试
	char a[]="(6+3)/(1+3!)";"(0!+1)*2^(3!+4)-(5!-67-(8+9))"
	char* RPN=new char[30];
	float ans=evaluate(a,RPN);
	float ans2=rpnEvaluation(RPN);
	cout<<a<<endl;
	cout<<ans<<endl;
	cout<<RPN<<endl;
	cout<<ans2<<endl;
*/
#endif
```

# Queue

```cpp
#ifndef QUEUE_H
#define QUEUE_H

#include"List.h"

template <typename T>
class Queue :public List<T> {
public:
	void push(T t) { insertAsLast(t); }
	T pop() { return removeAtFirst(); }
};
#endif
```

# BinTreeNode

```cpp
#ifndef BINTREENODE_H
#define BINTREENODE_H

//快捷方式
#define isRoot(x) (!(x)->parent)
#define isLChild(x) ((x)->parent&&(x)->parent->lchild==x)
#define isRChild(x) ((x)->parent&&(x)->parent->rchild==x)
#define hasLChild(x) ((x)->lchild)
#define hasRChild(x) ((x)->rchild)
#define hasChild(x) ((x)->lchild||(x)->rchild)
#define hasBothChild(x) ((x)->lchild&&(x)->rchild)
#define isLeaf(x) (!hasChild(x))

#define stature(x) ((x)?x->height:-1)//与空树高度为-1的语义相吻合
#define balanceFac(x) (stature((x)->lchild)-stature((x)->rchild))
#define isAvlBalanced(x) (-1<=balanceFac(x)&&balanceFac(x)<=1)

//获得左右孩子中较高者，如果同高，则与父节点同侧者优先
#define tallerChild(x) (\
	stature((x)->lchild)>stature((x)->rchild)?((x)->lchild):(\
	stature((x)->rchild)>stature((x)->lchild)?((x)->rchild):(\
	isLChild(x)?((x)->rchild):((x)->lchild)\
	)\
	)\
)
#define uncle(x)(\
	isLChild((x)->parent)?\
	((x)->parent->parent->rchild):\
	((x)->parent->parent->lchild)\
)
#define sibling(x)(isLChild(x)?(x)->parent->rchild:(x)->parent->lchild)
//获得x的父节点到其的链接，若其为根，则返回根节点，用于更新链接，而碎语原来不存在的链接，不可用，比如BST的插入新节点的新建链接时，可用于AVL树和红黑树的动态调整的递归当中
#define fromParentTo(x) (isRoot(x)?_root:(isLChild(x)?(x)->parent->lchild:(x)->parent->rchild))
//红黑树专用
typedef enum { RB_RED, RB_BLACK } RBColor;//节点颜色
#define isBlack(x) (!(x)||((x)->color==RB_BLACK))//空节点只能在最底层，定义为黑节点
#define isRed(x) (!isBlack(x))
//注意下面这个注释和\的位置，\必须放在最后，否则就报错了
#define BlackHeightUpdated(x) (/*红黑树高度更新条件*/\
	stature(x->lchild)==stature(x->rchild) &&\
	x->height==(isRed(x)?stature(x->lchild):stature(x->rchild)+1)\
)

template <typename T>
struct BinTreeNode {
	//节点数据
	T data;
	BinTreeNode<T> *parent, *lchild, *rchild;
	int height;//通用,教材中规定仅含单个节点的树高度为0，空树高度为-1
	RBColor color;

	//构造函数
	BinTreeNode() :parent(NULL), lchild(NULL), rchild(NULL), height(0), color(RB_RED) {}

	BinTreeNode(T e, BinTreeNode<T> *p = NULL, BinTreeNode<T> *l = NULL, BinTreeNode<T> *r = NULL, int h = 0, RBColor c = RB_RED) :data(e), parent(p), lchild(l), rchild(r), height(h), color(c) {
		if (l)l->parent = this; if (r)r->parent = this;
	}

	//操作接口
	BinTreeNode<T>* insertAsLC(T const& e);
	BinTreeNode<T>* insertAsRC(T const& e);
	BinTreeNode<T>* succ();//当前节点的直接后继
	template<typename VST> void travIn(VST& visit) { travIn_R(this, visit); }//操作器，recursion递归
	template<typename VST> void travPre(VST& visit) { travPre_R(this, visit); }
	template<typename VST> void travPost(VST& visit) { travPost_R(this, visit); }
	template<typename VST> void travLevel(VST& visit) { travLevel_R(this, visit); }

	//比较器、判等器
	bool operator<(BinTreeNode<T> const& btn) { return data < btn.data; }
	bool operator=(BinTreeNode<T> const& btn) { return data == btn.data; }
};

//接口实现

template<typename T>
BinTreeNode<T>* BinTreeNode<T>::insertAsLC(T const& e) {
	return lchild = new BinTreeNode(e, this);
}

template<typename T>
BinTreeNode<T>* BinTreeNode<T>::insertAsRC(T const& e) {
	return rchild = new BinTreeNode(e, this);
}

//遍历算法
template<typename T, typename VST>//元素类型，操作器
void travIn_R(BinTreeNode<T>* x, VST& visit) {
	if (!x)return;
	travIn_R(x->lchild, visit);
	//visit(x->data);
	cout << x->data << " height:" << x->height << " color:(0红1黑)" << x->color << endl;
	travIn_R(x->rchild, visit);
}

//直接后继
template<typename T>
BinTreeNode<T>* BinTreeNode<T>::succ() {
	BinTreeNode<T>* x = this;
	if (rchild) {
		x = rchild;
		while (x->lchild)x = x->lchild;
	}
	else {
		while (x->parent && (x->parent->rchild == x))x = x->parent;
		x = x->parent;
	}
	return x;
}
#endif
```

# BinTree

```cpp
//基本二叉树
#ifndef BINTREE_H
#define BINTREE_H

#include"BinTreeNode.h"

template<typename T>
class BinTree {
protected:
	int _size;
	BinTreeNode<T>* _root;
	//虚函数强制要求派生类更新其对应好函数，更新节点x高度
	virtual int updateHeight(BinTreeNode<T>* x);
	BinTreeNode<T>* removeAt(BinTreeNode<T>*& x, BinTreeNode<T>*& hot);
public:

	void updateHeightAbove(BinTreeNode<T>* x);//更新节点x及其祖先高度

	//构造析构
	BinTree() :_size(0), _root(NULL) {}
	//~BinTree(){if(0<_size)remove(_root);}
	//int remove(BinTreeNode<T>* x){return 0;}//删除根为x的子树，返回该子树原来的规模


	int size()const { return _size; }
	BinTreeNode<T>* root() { return _root; }
	bool empty()const { return !_root; }

	//插入节点
	BinTreeNode<T>* insertAsRoot(T const& e) { _size++; return _root = new BinTreeNode<T>(e); }
	BinTreeNode<T>* insertAsLC(BinTreeNode<T>* x, T const& e) { _size++; return x->insertAsLC(e); }
	BinTreeNode<T>* insertAsRC(BinTreeNode<T>* x, T const& e) { _size++; return x->insertAsRC(e); }
	BinTreeNode<T>* attachAsLC(BinTreeNode<T>* x, BinTree<T> &tree);//tree作为x左子树接入
	BinTreeNode<T>* attachAsRC(BinTreeNode<T>* x, BinTree<T> &tree);//tree作为x右子树接入

	//遍历
	template<typename VST>//操作器
	void travIn(VST& visit) { if (_root) { _root->travIn(visit); cout << endl; } }
};
//更新包括x在内的以上节点，用其两个孩子节点的值来判断
template<typename T>
void BinTree<T>::updateHeightAbove(BinTreeNode<T>* x) {
	while (x) {
		updateHeight(x);
		x = x->parent;
	}
}
template<typename T>
int BinTree<T>::updateHeight(BinTreeNode<T>* x) {
	if (hasBothChild(x))
		return x->height = (x->lchild->height > x->rchild->height ?\
			x->lchild->height : x->rchild->height) + 1;
	if (x->rchild)return x->height = x->rchild->height + 1;
	if (x->lchild)return x->height = x->lchild->height + 1;
	return x->height = 0;
}

//返回值为被删除节点的接替者，hot是被删除节点的父节点，两者均可能为空
//这里的hot为引用型指针，因为要改变hot的值，如果不改变原指针的值的话不需要用引用型
template<typename T>
BinTreeNode<T>* BinTree<T>::removeAt(BinTreeNode<T>*& x, BinTreeNode<T>*& hot) {
	BinTreeNode<T>* w = x;//记录实际被摘除的节点初值为x
	BinTreeNode<T>* succ = NULL;//记录被删除节点的继任者
	//书中没有考虑被删除节点的父节点与继任者链接的问题,书中也没有考虑到被删除节点是根节点的问题
	if (!x->lchild) { succ = x = x->rchild; fromParentTo(w) = x; }//(hot->lchild==w?hot->lchild:hot->rchild)=x;//书上这里代码写错了，少写了一句，导致缺少链接
	else if (!x->rchild) { succ = x = x->lchild; fromParentTo(w) = x; }//(hot->lchild==w?hot->lchild:hot->rchild)=x;}
	else {//左右子树均存在的情况下，用x的直接后继来替代x，因为其直接后继没有左孩子，就可以转化为简单的情况.
		w = w->succ();
		swap(x->data, w->data);
		BinTreeNode<T>* u = w->parent;//被删除节点的父亲，和hot相等
		((u == x) ? u->rchild : u->lchild) = succ = w->rchild;//隔离要删除节点w
	}
	hot = w->parent;

	if (succ)succ->parent = hot;
	delete w;
	return succ;
}
#endif
```

# BinSearchTree

```cpp
//二叉搜索树
//重要算法：search、insert、remove
#ifndef BINSEARCHTREE_H
#define BINSEARCHTREE_H

#include"BinTree.h"
template<typename T>
class BinSearchTree :public BinTree<T> {
protected:
	BinTreeNode<T>* _hot;//search函数中最后访问的非空位置
public:
	//虚函数强制要求派生类根据各自的规则对其重写
	//只有虚函数是动态绑定的，如果派生类需要重写基类函数，就要把这些函数声明为虚函数。
	//而声明中的非虚函数，通常代表那些不希望被派生类修改的功能。
	virtual BinTreeNode<T>* search(const T& e);
	virtual BinTreeNode<T>* insert(const T& e);
	virtual bool remove(const T& e);

	BinTreeNode<T>* rotateAt(BinTreeNode<T>* v);//节点变化统一算法，返回调整后局部子树根节点位置。注意子树会链接到上层节点，但是上层节点到局部子树根节点的链接要上层函数完成

	BinTreeNode<T>* connect34(//三四重构
		BinTreeNode<T>* a, BinTreeNode<T>* b, BinTreeNode<T>* c,
		BinTreeNode<T>* T0, BinTreeNode<T>* T1, BinTreeNode<T>* T2, BinTreeNode<T>* T3
	);
};

//语义规定：搜索到就返回该节点的指针，否则返回搜索的最后一个节点的指针，即_hot
template<typename T>
BinTreeNode<T>* BinSearchTree<T>::search(const T& e) { return searchIn(_root, e, _hot = NULL); }

template<typename T>
BinTreeNode<T>* BinSearchTree<T>::insert(const T& e) {
	if (!_root) { _size++; return _root = new BinTreeNode<T>(e); }//处理空树
	BinTreeNode<T>* x = search(e);
	if (x)return x;
	x = new BinTreeNode<T>(e, _hot);//以hot为父节点创建节点
	if (e < _hot->data)_hot->lchild = x;	else _hot->rchild = x;//这一句书中没有，是一个大budge
	_size++;
	updateHeightAbove(x);
	return x;
}

template<typename T>
bool BinSearchTree<T>::remove(const T& e) {
	BinTreeNode<T>* x = search(e);
	if (!x)return false;//要删除的节点不存在
	removeAt(x, _hot);//hot是x的父节点,若x为根节点，hot为空
	_size--;
	updateHeightAbove(_hot);
	return true;
}

template<typename T>
BinTreeNode<T>* BinSearchTree<T>::connect34(//三四重构
	BinTreeNode<T>* a, BinTreeNode<T>* b, BinTreeNode<T>* c,
	BinTreeNode<T>* T0, BinTreeNode<T>* T1, BinTreeNode<T>* T2, BinTreeNode<T>* T3
) {
	a->lchild = T0; if (T0)T0->parent = a;//这里别忘了if(T0),以为空指针没有父子节点等，会出现内存访问出错
	a->rchild = T1; if (T1)T1->parent = a; updateHeight(a);
	c->lchild = T2; if (T2)T2->parent = c;
	c->rchild = T3; if (T3)T3->parent = c; updateHeight(c);
	b->lchild = a; a->parent = b;
	b->rchild = c; c->parent = b; updateHeight(b);
	return b;
}

template<typename T>
BinTreeNode<T>* BinSearchTree<T>::rotateAt(BinTreeNode<T>* v) {//v为非空的孙辈节点
	BinTreeNode<T>* p = v->parent; BinTreeNode<T>* g = p->parent;
	//视p，g不同的相对位置分四种情况讨论，分别是zigzig、zagzag、zigzag、zagzig
	if (isLChild(p)) {
		if (isLChild(v)) {
			p->parent = g->parent;//向上链接，因为connect34函数并没有实现这个
			return connect34(v, p, g, v->lchild, v->rchild, p->rchild, g->rchild);
		}
		else {
			v->parent = g->parent;
			return connect34(p, v, g, p->lchild, v->lchild, v->rchild, g->rchild);
		}
	}else {
		if (isLChild(v)) {
			v->parent = g->parent;
			return connect34(g, v, p, g->lchild, v->lchild, v->rchild, p->rchild);//这一句刚开始粗心写错了，调试过程中发现了,细心也很重要啊，这种错误估计也只能在调试中发现了
		}else {
			p->parent = g->parent;
			return connect34(g, p, v, g->lchild, p->lchild, v->lchild, v->rchild);
		}
	}
}

//static函数与普通函数的区别：用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。
template<typename T>
static BinTreeNode<T>* searchIn(BinTreeNode<T>* v, const T& e, BinTreeNode<T>*& hot) {
	if (!v || v->data == e)return v;//在空指针处假想通配符
	hot = v;
	return searchIn((e < v->data ? v->lchild : v->rchild), e, hot);
}

//template<typename T>
static void swap(int & a, int & b) {
	int tmp = a; a = b; b = tmp;
}
#endif
```

# AVLTree

```cpp
#ifndef AVLTREE_H
#define AVLTREE_H
//适度平衡树：树高渐进意义上不超过logn
//AVL树：兄弟节点高度相差最多为1
//局部性特征:1)经过单次动态修改后，最多只有O(1)处局部不再满足条件；2)总可以在logn的时间内，使得这些局部重新满足条件
//重要算法：zig、zag（上下可变、左右不乱，子树高度变化不超过1）
#include"BinSearchTree.h"

template<typename T>
class AVLTree :public BinSearchTree<T> {
public:
	BinTreeNode<T>* insert(const T& e);//重写insert函数
	bool remove(const T& e);//重写remove函数
	//search函数沿用
};

template<typename T>
BinTreeNode<T>* AVLTree<T>::insert(const T& e) {
	if (!_root) { _size++; return _root = new BinTreeNode<T>(e); }//处理空树
	BinTreeNode<T>* x = search(e);
	if (x)return x;
	x = new BinTreeNode<T>(e, _hot); _size++;
	if (e < _hot->data)_hot->lchild = x;	else _hot->rchild = x;//这一句书中没有，是一个大budge
	//创建新节点后，其父节点高度可能变化，其祖父节点及以上可能失衡
	for (BinTreeNode<T>* g = _hot; g; g = g->parent) {//由父节点往上寻找失衡节点
		if (!isAvlBalanced(g)) {
			//前往别忘了把重整后的子树的顶点链接到原父节点，因为rotate函数只是把涉及到的链接都做好了，而g的父节点不在其处理范围之内
			fromParentTo(g) = rotateAt(tallerChild(tallerChild(g)));//调整失衡节点,rotate()在BinSearchTree中声明和实现
			break;
		}
		else {
			updateHeight(g);
		}
	}
	return x;
}

template<typename T>
bool AVLTree<T>::remove(const T& e) {
	BinTreeNode<T>* x = search(e);
	if (!x)return false;
	removeAt(x, _hot); _size--;//先按照BST的规则进行删除，然后在重新平衡
	for (BinTreeNode<T>* g = _hot; g; g = g->parent) {
		if (!isAvlBalanced(g))
			g = fromParentTo(g) = rotateAt(tallerChild(tallerChild(g)));
		updateHeight(g);//应该意识到，即使g没有失衡，高度也可能降低
	}
	return true;
}
#endif
```

# SplayTree

```cpp
#ifndef SPLAYTREE_H
#define SPRAYTREE_H
//AVL痛点：每次插入删除要调整，可以说AVL树是一个时时小心处处谨慎的人
//伸展树：利用局部性：刚刚访问过的元素，极有可能再次被访问.
//策略：节点一旦被访问，随即调整到树根。即逐层单旋，直到树根，但这种策略有最坏情况，即退化成单链的情况，这时候分摊复杂度也有O(n)\
//策略点睛：将单层伸展改为双层伸展，有四种情况，其中zigzag、zagzig，和AVL树双旋完全等效，采用自下而上两次单旋，zigzig、zagzag，有细微的差异，将从下而上的单旋改为从上而下的单旋，这个细微的差异将是颠覆性的
//折叠效果：一旦访问坏节点，对应路径长度至少减半，最坏情况不至于持续发生，此时的分摊复杂度为O(logn)
//关键算法：splay()将定点自下而上转移到根节点
//有了splay算法，search、insert、remove都非常方便

#include"BinSearchTree.h"

template <typename T>
class SplayTree :public BinSearchTree<T> {
protected:
	BinTreeNode<T>* splay(BinTreeNode<T>* v);//将节点v移到树根
public:
	BinTreeNode<T>* insert(const T& e);//重写insert函数
	bool remove(const T& e);//重写remove函数
	BinTreeNode<T>* search(const T& e);//重写search函数
};

template<typename NodePosi>inline void attachAsLChild(NodePosi p, NodePosi lc) { p->lchild = lc; if (lc)lc->parent = p; }

template<typename NodePosi>inline void attachAsRChild(NodePosi p, NodePosi rc) { p->rchild = rc; if (rc)rc->parent = p; }

template<typename T>
BinTreeNode<T>* SplayTree<T>::splay(BinTreeNode<T>* v) {
	if (!v)return NULL;
	BinTreeNode<T> *p, *g, *gg;
	//用if-else判断四种情况实现双旋操作，与书中定义保持一致，zigzag指对p进行zig，对g进行zag，故先判断v节点，再判断p节点
	while ((p = v->parent) && (g = p->parent)) {
		gg = g->parent;
		if (isLChild(v)) {
			if (isLChild(p)) {//zigzig
				attachAsLChild(p, v->rchild); attachAsLChild(g, p->rchild);
				attachAsRChild(p, g); attachAsRChild(v, p);
			}else {//zigzag
				attachAsRChild(g, v->lchild); attachAsLChild(p, v->rchild);
				attachAsRChild(v, p); attachAsLChild(v, g);
			}
		}else {
			if (isLChild(p)) {//zagzig
				attachAsRChild(p, v->lchild); attachAsLChild(g, v->rchild);
				attachAsRChild(v, g); attachAsLChild(v, p);
			}else {//zagzag
				attachAsRChild(p, v->lchild); attachAsRChild(g, p->lchild);
				attachAsLChild(p, g); attachAsLChild(v, p);
			}
		}
		//将v与gg链接
		if (!gg)v->parent = NULL;
		else (gg->lchild == g) ? attachAsLChild(gg, v) : attachAsRChild(gg, v);
		updateHeight(g); updateHeight(p); updateHeight(v);//顺序不可颠倒
	}//伸展结束后，必有g=NULL，而p不一定
	if (p = v->parent) {//最后一步单旋
		if (isLChild(v)) { attachAsLChild(p, v->rchild); attachAsRChild(v, p); }
		else { attachAsRChild(p, v->lchild); attachAsLChild(v, p); }
		v->parent = NULL;
		updateHeight(p); updateHeight(v);
	}
	return v;
}

template<typename T>
BinTreeNode<T>* SplayTree<T>::search(const T& e) {
	BinTreeNode<T>* p = searchIn(_root, e, _hot = NULL);
	_root = splay((p ? p : _hot));
	return _root;
}
template<typename T>
BinTreeNode<T>* SplayTree<T>::insert(const T& e) {
	if (!_root) { _size++; return _root = new BinTreeNode<T>(e); }//处理空树
	if (search(e)->data == e)return _root;//要插入的节点已存在
	_size++; BinTreeNode<T>* t = _root;
	if (e < _root->data) {
		_root = new BinTreeNode<T>(e, NULL, t->lchild, t);
		t->lchild = NULL;
	}else {
		_root = new BinTreeNode<T>(e, NULL, t, t->rchild);
		t->rchild = NULL;
	}
	updateHeightAbove(t);
	return _root;
}

template<typename T>
bool SplayTree<T>::remove(const T& e) {
	if (search(e)->data != e)return false;//要删除的节点不存在
	BinTreeNode<T>* t = _root;
	if (!hasLChild(t)) {//没有左子树直接删除
		_root = _root->rchild; if (_root)_root->parent = NULL;
	}else if (!hasRChild(t)) {//没有右子树直接删除
		_root = _root->lchild; if (_root)_root->parent = NULL;
	}else {//左右子树存在，令根节点的直接后继作为新的根
		BinTreeNode<T>* ltree = _root->lchild;
		ltree->parent = NULL; _root->lchild = NULL;//暂时将左子树隔离
		_root = _root->rchild; _root->parent = NULL;//只保留右子树
		search(t->data);//对右子树进行一个失败的查找，但右子树的最小定点此时一定在根节点，且其左子树必为空
		_root->lchild = ltree; ltree->parent = _root;//将原左子树接回去
	}
	if (_root)updateHeight(_root);
	delete t; _size--;
	return true;
}
#endif
```

# RedBlackTree

```cpp
#ifndef REDBLACKTREE_H
#define REDBLACKTREE_H
//适度平衡树：树高渐进意义上不超过logn
//红黑树：从树根到叶节点的通路总是包含一样多的黑点
//局部性特征:1)经过单次动态修改后，最多只有O(1)处局部不再满足条件；2)总可以在logn的时间内，使得这些局部重新满足条件
//红黑树动机：保存历史版本，利用各个版本之间的关联性，使得空间复杂度达到O(n+h*logn)而非O(n*h)，h表示历史版本树，n表示树的规模
//考察两个版本之间的差异，AVL树insert差异在O(1)remove是O(logn)，Spray树search、insert、remove都是O(logn)，B树insert是O(1)，remove是O(logn)，这种概率好像很小？
//红黑树可以保证两个版本之间的差异在O(1)
//根节点外部节点均为黑色，假想外部节点，即空节点
//红节点的父亲还是都是黑节点
//外部节点到根，途径的黑节点的个数是一致的
//红黑树的定义让人费解，更简单的理解是：利用提升变换（将每一个红节点提升一层），即得到了一颗（2,4）树，而每条路径黑节点的数目即为树高
//红黑树的插入删除等拓扑结构的变化不容易理解，所以，时时刻刻在脑海中有一个B树的影子方便理解，先想想变换前对应的B树，然后根据B树进行变化，然后在改为红黑树
//红黑树的每次insert和remove操作都只是常数次的结构调整和O(logn)的染色操作，这也是红黑树优于AVL树的主要方面

#include"BinSearchTree.h"

template<typename T>
class RedBlackTree :public BinSearchTree<T> {
public:
	//BinTreeNode<T>* search(const T& e);//沿用search接口
	BinTreeNode<T>* insert(const T& e);//重写insert接口
	bool remove(const T& e);//重写remove接口，以保证拓扑变换符合红黑树要求
protected:
	int updateHeight(BinTreeNode<T>* v);//这里的高度定义为黑高度，只计算黑节点的高度
	void solveDoubleBlack(BinTreeNode<T>* v);//修复双黑节点的情况
	void solveDoubleRed(BinTreeNode<T>* v);//修复双红节点的情况
};

template <typename T>
int RedBlackTree<T>::updateHeight(BinTreeNode<T>* v) {
	v->height = max(stature(v->lchild), stature(v->rchild));
	if (isBlack(v))v->height++;
	return v->height;
}

//插入节点
template <typename T>
BinTreeNode<T>* RedBlackTree<T>::insert(const T& e) {
	//处理空树
	if (!_root) { _size++; return _root = new BinTreeNode<T>(e, NULL, NULL, NULL, 0, RB_BLACK); }
	BinTreeNode<T>* x = search(e);
	if (x)return x;//插入节点已存在
	x = new BinTreeNode<T>(e, _hot, NULL, NULL, -1);//注意这里红黑树的高度定义和BST不同，指的是黑高度
	if (e < _hot->data)_hot->lchild = x;	else _hot->rchild = x;//这一句书中没有，是一个大budge。前面已经处理过空树，所以这里_hot必存在
	_size++;
	solveDoubleRed(x);
	//返回插入的节点
	return x ? x : _hot->parent;
}

template<typename T>
void RedBlackTree<T>::solveDoubleRed(BinTreeNode<T>* v) {
	//若递归至根节点，当然是RR-2这种情况才会向上递归，而此时根节点为红色，所以，应将其染黑，并且树高加1
	if (isRoot(v)) { _root->height++; _root->color = RB_BLACK; return; }
	BinTreeNode<T>* p = v->parent;//插入节点后其父节点必存在
	if (isBlack(p))return;//无需调整
	//第一次插入时，x的uncle节点必为空（黑），但是当双红缺陷向上蔓延时，其uncle节点就不一定是黑节点了。
	//RR-1（uncle为黑节点），从（2,4）树的角度来看，其实节点数并没有超过限制，而是黑节点不再居中，调整黑节点居中即可，对x节点用34重构即可，然后重新染色，这种调整不会向上蔓延；RR-2节点数超过限制，应该分裂，具体的做法是逐层上升，但是可以发现，此时只需要染色，不需要拓扑变化
	BinTreeNode<T>* g = p->parent;//g必存在，且颜色为黑
	BinTreeNode<T>* u = uncle(v);
	if (isBlack(u)) {//RR-1（uncle为黑节点）
		//先对各节点重新染色，然后34重构
		if (isLChild(v) == isLChild(p))p->color = RB_BLACK;
		else v->color = RB_BLACK;
		g->color = RB_RED;
		BinTreeNode<T>* gg = g->parent;
		BinTreeNode<T>* r = fromParentTo(g) = rotateAt(v);
		r->parent = gg;
	}else {//RR-2（uncle为红节点）
		g->color = RB_RED;//书中在这里添加了判断g是否是根节点，其实不需要，因为该函数入口处已经对根节点的情况进行了处理
		u->color = RB_BLACK; u->height++;
		p->color = RB_BLACK; p->height++;
		solveDoubleRed(g);
	}
}

template <typename T>
bool RedBlackTree<T>::remove(const T& e) {
	BinTreeNode<T>* x = search(e);
	if (!x)return false;//要删除元素不存在
	BinTreeNode<T>* r = removeAt(x, _hot);//r为x的接替者
	if (!(--_size))return true;//删除节点后为空树，可直接返回
	//_hot某一孩子刚被删除，且被r所指向节点（可能是NULL）替代，以下检查是否失衡
	if (!_hot) { _root->color = RB_BLACK; updateHeight(_root); return true; }//只有当x的左右孩子都存在的情况下，才会用其直接后继r与x交换数据，然后删除x，所以，书上这句是不需要的吧
	//以下分别判断三种情况，x、r的颜色
	if (BlackHeightUpdated(_hot))return true;//x、r分别是红黑的情况，_hot的深度不变
	if (isRed(r)) { r->color = RB_BLACK; r->height++; return true; }//x、r分别是黑红的情况，只需将r染黑
	solveDoubleBlack(r); return true;//第三种情况，双黑缺陷
	return NULL;
}

template <typename T>
void RedBlackTree<T>::solveDoubleBlack(BinTreeNode<T>* v) {
	//根据24树的情况，大类分三种情况，1跟兄弟节点借；2跟父亲节点借；3合并
	BinTreeNode<T>* p = v ? v->parent : _hot;//父节点
	if (!p)return;//处理退化到根节点的情况
	BinTreeNode<T>* s = (p->lchild == v) ? p->rchild : p->lchild;//兄弟节点
	//递归基,下面这句是不对的，书上没有这句
	//但是书中考虑了退化到根节点的情况，应该写上
	//if(isRoot(v))return;

	if (isBlack(s)) {
		BinTreeNode<T>* t = NULL;//s的红孩子，左孩子优先，没有时为NULL
		if (isRed(s->rchild))t = s->rchild;
		if (isRed(s->lchild))t = s->lchild;
		if (t) {//跟兄弟节点借，即s为黑，且有红孩子
			RBColor oldColor = p->color;
			BinTreeNode<T>* b = fromParentTo(p) = rotateAt(t);
			if (hasLChild(b)) { b->lchild->color = RB_BLACK; updateHeight(b->lchild); }
			if (hasRChild(b)) { b->rchild->color = RB_BLACK; updateHeight(b->rchild); }
			b->color = oldColor; updateHeight(b);
		}else {//s没有红孩子
			s->color = RB_RED; s->height--;
			if (isRed(p)) {
				p->color = RB_BLACK;
			}else {
				p->height--;
				solveDoubleBlack(p);
			}
		}
	}else {//兄弟s为红
		s->color = RB_BLACK; p->color = RB_RED;
		BinTreeNode<T>* t = isLChild(s) ? s->lchild : s->rchild;
		_hot = p; fromParentTo(p) = rotateAt(t);
		solveDoubleBlack(v);//继续修正r处双黑，但是因为p已转红，修复的情况最多只有一步
	}
}
#endif
```

# BTree

```cpp
#ifndef BTREE_H
#define BTREE_H

//BTree，多路平衡搜索树
//动机：系统存储容量的增长速度远远小于问题规模的增长速度，而内存的容量越大，访问速度就越慢
//高速缓存：1）不同容量的存储器，访问速度差异巨大，如果内存访问时1s，那么外存就要1day；2）从磁盘中读取1B，和读取1KB几乎一样快，以页或者块为单位，批量访问内存
//B树：1）不是二叉树，多叉树，所有底层节点的深度是一致的
//B树的目的是实现高速IO
//B是的每个节点是有两个向量，一个包含关键码，另一个包含指向下一个超级节点的指针
//m阶B树，内部节点的关键码的个数最大m-1，最大分支树m；最小关键码个数「m/2]
//关键算法：因插入而上溢之后采取的分裂处理；因删除而下溢之后采取的合并处理

//快捷方式
#define _mid (_order/2)//设置分裂时的中位数
#define _hi (_order)
#define _lo ((_order%2)?(_order/2):(_order/2-1))//设置关键码的上下界[lo,hi）


#include"BTreeNode.h"

template <typename T>
class BTree {
protected:
	int _size;//存放的关键码总数，每一个超级节点是一个关键码
	int _order;//B树的阶数，一般不能修改
	BTreeNode<T>* _root;
	BTreeNode<T>* _hot;//search接口最后访问的非空节点位置
	//BTree(){}
	void solveOverflow(BTreeNode<T>* t);//因插入而上溢之后采取的分裂处理
	void solveUnderflow(BTreeNode<T>* t);//；因删除而下溢之后采取的合并处理
public:
	BTree(const int order) :_order(order) { _size = 0; _root = new BTreeNode<T>(); }
	BTreeNode<T>* search(const T& e);
	BTreeNode<T>* insert(const T& e);
	bool remove(const T& e);
};

//查找接口实现
template <typename T>
BTreeNode<T>* BTree<T>::search(const T& e) {
	BTreeNode<T>* v = _root; _hot = NULL;//从根节点出发
	while (v) {
		Rank r = v->key.find(e);
		if (r >= 0 && v->key[r] == e)return v;//查找成功
		else {//查找失败，继续深入一层
			_hot = v;
			v = v->child[r + 1];
		}
	}//若查找到了根节点，意味着查找失败
	return NULL;
}

//插入接口的实现
template <typename T>
BTreeNode<T>* BTree<T>::insert(const T& e) {
	BTreeNode<T>* x = search(e);
	if (x)return x;
	Rank r = _hot->key.find(e);
	_hot->key.insert(r + 1, e);
	_hot->child.push_back(NULL);
	_size++;
	solveOverflow(_hot);
	return _hot;
}

//删除接口的实现
template <typename T>
bool BTree<T>::remove(const T& e) {
	BTreeNode<T>* x = search(e);
	if (!x)return false;
	Rank r = x->key.find(e);
	if (x->child[0]) {//说明x不在最底层，需要寻找该删除节点的直接后继，然后交换其位置，这样就能保证被删除节点在最后一层
		BTreeNode<T>* w = x->child[r + 1];
		while (w->child[0])w = w->child[0];
		x->key[r] = w->key[0]; x = w; r = 0;
	}
	x->key.remove(r);
	x->child.pop_back();
	_size--;
	solveUnderflow(x);
	return true;
}

//处理因插入而产生的上溢操作，此时，v是可能上溢的超级节点
template<typename T>
void BTree<T>::solveOverflow(BTreeNode<T>* v) {//v代表当前节点，u代表其父节点,x代表新节点
	//已用宏定义的方式定义了_mid\_lo\_hi三个变量，设置分裂时的秩中位数_mid\关键码的上下界[lo,hi）
	if (v->key.size() < _hi)return;//递归基
	//分裂节点
	BTreeNode<T>* x = new BTreeNode<T>(v->key[_mid + 1], v->child[_mid + 1], v->child[_mid + 2]);
	for (int i = _mid + 2; i < _hi; i++) { x->key.push_back(v->key[i]); x->child.push_back(v->child[i + 1]); }

	if (!v->parent) {//若分裂节点是根节点，这是B树高度增加的唯一情况
		_root = new BTreeNode<T>(v->key[_mid], v, x);
		//v->key.remove(_mid,_hi);v->child.remove(_mid+1,_hi+1);
	}else {//分裂节点不是根节点
		BTreeNode<T>* u = v->parent;
		Rank r = u->key.find(v->key[_mid]);
		u->key.insert(r + 1, v->key[_mid]);
		u->child.insert(r + 2, x);
		x->parent = u;//别忘了这一句，x父节点指向u
		solveOverflow(u);
	}
	v->key.remove(_mid, _hi); v->child.remove(_mid + 1, _hi + 1);
}

//处理因删除而产生的下溢操作，此时，v是可能下溢的超级节点
template<typename T>
void BTree<T>::solveUnderflow(BTreeNode<T>* v) {//v代表当前节点，u代表其父节点
	//已用宏定义的方式定义了_mid\_lo\_hi三个变量，设置分裂时的秩中位数_mid\关键码的上下界[lo,hi）
	if (!v->parent)return;//递归基：跟节点不存在下溢
	if (v->key.size() >= _lo)return;//递归基
	BTreeNode<T>* u = v->parent;
	//存在下溢时，先左顾右盼，借不到元素再合并
	Rank r = u->key.find(v->key[0]);
	BTreeNode<T>* x;//借元素或者合并的节点
	if (r >= 0 && (u->child[r]->key.size() > _lo)) {//从左边借
		x = u->child[r];
		v->key.insert(0, u->key[r]);
		v->child.insert(0, x->child[x->child.size() - 1]); if (x->child[x->child.size() - 1])x->child[x->child.size() - 1]->parent = v;
		u->key[r] = x->key[x->key.size() - 1];
		x->key.pop_back(); x->child.pop_back();
	}else if ((r <= u->key.size() - 2) && (u->child[r + 2]->key.size() > _lo)) {//从右边借
		x = u->child[r + 2];
		v->key.push_back(u->key[r + 1]);
		v->child.push_back(x->child[0]); if (x->child[0])x->child[0]->parent = v;
		u->key[r + 1] = x->key[0];
		x->key.remove(0); x->child.remove(0);
	}else if (r >= 0) {//与左边合并		
		x = u->child[r];
		x->key.push_back(u->key[r]);
		x->child.push_back(v->child[0]); if (v->child[0])v->child[0]->parent = x;
		for (int i = 0; i < v->key.size(); i++) {
			x->key.push_back(v->key[i]);
			x->child.push_back(v->child[i + 1]); if (v->child[i + 1])v->child[i + 1]->parent = x;
		}
		delete v;
		//需要合并的时候，应判断u是不是根节点且只有一个元素，这是B树高度降低的唯一情况
		if (!u->parent&&u->key.size() == 1) {
			_root = x; x->parent = NULL;
			delete u;
		}
		else {
			u->key.remove(r); u->child.remove(r + 1);
			solveUnderflow(u);
		}
	}else {//与右边合并
		x = u->child[r + 2];
		v->key.push_back(u->key[r + 1]);
		v->child.push_back(x->child[0]); if (x->child[0])x->child[0]->parent = v;
		for (int i = 0; i < x->key.size(); i++) {
			v->key.push_back(x->key[i]);
			v->child.push_back(x->child[i + 1]); if (x->child[i + 1])x->child[i + 1]->parent = x;
		}
		delete x;
		//需要合并的时候，应判断u是不是根节点且只有一个元素，这是B树高度降低的唯一情况
		if (!u->parent&&u->key.size() == 1) {
			_root = v; v->parent = NULL;
			delete u;
		}else {
			u->key.remove(r + 1); u->child.remove(r + 2);
			solveUnderflow(u);
		}
	}
}
#endif
```

# Priority_queue

```cpp
#ifndef PRIORITYQUEUE_H
#define PRIORITYQUEUE_H
//优先级队列不是一种数据结构，而是ADT，这里主要做到用完全二叉堆实现优先级队列
template<typename T>
struct PriorityQueue {
	virtual void insert(T) = 0;//按照优先级次序插入词条
	virtual T getMax() = 0;//获得优先级最高的词条
	virtual T delMax() = 0;//删除优先级最高的词条
};
#endif
```

# CompleteHeap

```cpp
#ifndef COMPLETEHEAP_H
#define COMPLETEHEAP_H

#include"PriorityQueue.h"
#include"Vector.h"

//完全二叉堆，逻辑上的二叉树，形式上的向量
//快捷方式
#define parent(i) ((i-1)/2)
#define LChild(i) (2*i+1)
#define RChild(i) (2*i+2)

template<typename T>//i及其两个孩子中的最大者
Rank ProperParent(T* _elem, Rank n, Rank i) {
	if (RChild(i) < n) {
		if (_elem[RChild(i)] < _elem[LChild(i)]) {
			if (_elem[i] < _elem[LChild(i)])
				i = LChild(i);
		}
		else {
			if (_elem[i] < _elem[RChild(i)])
				i = RChild(i);
		}
	}else if (LChild(i) < n) {
		if (_elem[LChild(i)] > _elem[i])
			i = LChild(i);
	}
	return i;
}

//插入删除操作如此简洁明了，其保证是堆序性，即孩子的优先级小于父亲，上滤和下滤都是为了维护堆序性
template<typename T>
class CompleteHeap :public PriorityQueue<T>, public Vector<T> {
protected:
	Rank percolateDown(Rank n, Rank i);//下滤
	Rank percolateUp(Rank i);//上滤
	void heapify(Rank n);//Floyd建堆
public:
	CompleteHeap() :Vector<T>() {}//派生类的抽象函数要知道怎么写，不然就编译错了
	CompleteHeap(T* A, Rank n) { copyFrom(A, 0, n); heapify(n); }
	void insert(T);//按照优先级次序插入词条,先添加到最后一个，然后不断上升
	T getMax();//获得优先级最高的词条
	T delMax();//删除优先级最高的词条，先将头结点和最后一个节点交换位置，然后删除最后一个元素，在将首元素不断下降
};

template<typename T>
int CompleteHeap<T>::percolateUp(Rank i) {
	if (i == 0)return 0;
	Rank p = parent(i);
	//第一版上滤
	while (_elem[i] > _elem[p]) {
		swap(_elem[i], _elem[p]);
		if (p == 0)break;
		i = p; p = parent(p);
	}
	//第二版上滤
	return i;
}

template<typename T>
void CompleteHeap<T>::insert(T t) {
	push_back(t);
	int i = size() - 1;
	percolateUp(i);
}

template<typename T>
Rank CompleteHeap<T>::percolateDown(Rank n, Rank i) {
	Rank j;//i及其两个孩子中最大者
	while (i != (j = ProperParent(_elem, n, i))) { swap(_elem[i], _elem[j]); i = j; }
	return i;
}

template<typename T>
T CompleteHeap<T>::delMax() {
	T tmp = _elem[0];
	_elem[0] = _elem[--_size];
	percolateDown(_size, 0);
	return tmp;
}

template<typename T>
T CompleteHeap<T>::getMax() { return _elem[0]; }

template<typename T>
void CompleteHeap<T>::heapify(Rank n) {
	for (int i = n - 1; i >= 0; i--)percolateDown(n, i);
}
#endif
```

# Huffman

```cpp
#ifndef HUFFMAN_H
#define HUFFMAN_H

#include<iostream>

#include "CompleteHeap.h"
#include "BinTree.h"

//huffman编码的实现，构造最优前缀码的贪心算法
//变长的前缀码实现数据压缩，最优前缀码一定是满二叉树
//(1)哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。
//(2)算法以|C|个叶结点开始，执行|C|－1次的“合并”运算后产生最终所要求的树T。
//(3)假设编码字符集中每一字符c的频率是f(c)。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。一旦2棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的2棵树的频率之和，并将新树插入优先队列Q。经过n－1次的合并后，优先队列中只剩下一棵树，即所要求的树T。

//统计文档字符频率信息
#define N_CHAR (0x80-0x20)//只考虑可打印字符,0x20表示空格，0x7E是~，显示的是这之间的字符

int* statistics(char* filename) {
	int* freq = new int[N_CHAR];
	memset(freq, 0, sizeof(int)*N_CHAR);//清零
	FILE* fp = fopen(filename, "r");
	//FILE* fout=fopen("d:\\output.txt","w");
	for (char ch; 0 < fscanf(fp, "%c", &ch);)//这里%c不读取空格和回车等非打印字符？
		if (ch >= 0x20) {
			//fputc(ch,fout);
			freq[ch - 0x20]++;
			//cout<<ch;
		}
	//for(int i=0;i<N_CHAR;i++)printf("%c %d\n",i,freq[i]);
	fclose(fp);
	//fclose(fout);
	return freq;
}

//定义树节点数据，字符值和频率
struct huffnode {
	huffnode(char cc, int ff) :c(cc), f(ff) {}
	char c; int f;
	bool operator<(huffnode b) { return f <= b.f; }
	void operator=(huffnode b) { c = b.c; f = b.f; }
};

void huffman(char* filename) {
	//计算文件中各个字符的比率
	int* freq = statistics(filename);
	//用二叉堆编码树森林，二叉堆中保存各个森林的根节点
	//初始化，将所有频率非0的节点加入完全二叉堆
	Vector<BinTreeNode<huffnode>> t;//由向量构建二叉堆
	for (int i = 0; i < N_CHAR; i++) {
		if (freq[i] != 0) {
			huffnode a(i, freq[i]);
			BinTreeNode<huffnode> b(a);
			t.push_back(b);
		}
	}
}
#endif
```

# KMP

```cpp
//关键在于：利用模式串本身的特点，i不回溯，令j重新定位，然后接着比较
int KMP(char* T,int n,char* P,int m){
	int  i=0,j=0;
	while(i<=n-m&&j<m){
		if(j<0||T[i]==P[j])//左侧-1秩设置哨兵，与任何字符串均匹配
			{i++;j++;}
		else
			j=next[j];
	}
	return i-j;//若匹配成功，则i，j相等，返回0；
}

/*构造next表
next[j]表示在区间[0,j)的最长匹配前后缀（必须是真前缀）的数目
用dp方法求next[j],由于在-1设置哨兵，基址设置为next[0]=-1，即在0处不匹配时，i,j均加一
*/

int* buildNext(char* P){//构造模式串P的next表
	size_t m=strlen(P),j=0;
	int* N=new int[m];//next表
	int t=N[0]=-1;//模式串指针
	while(j<m-1){
		if(0>t||P[j]==P[t]){//匹配
			j++;t++;
			N[j]=(P[j]!=P[t]?t:N[t]);
		}else{
			t=N[t];
		}
	}
	return N;
}

//BM算法主体框架
int match(char* P,char* T){//兼容bad character和good suffix
	int* bc=buildBC(P);int* gs=buildGS(P);
	size_t i=0;
	while(strlen(T)>=i+strlen(P)){
		int j=strlen(P)-1;
		while(P[j]==T[i+j])if(0>--j)break;
		if(0>j)break;
		else i+=max(gs[j],j-bc[T[i+j]]);
	}
	delete[] gs;delete[] bc;
	return i;
}

int* buildBC(char* P){
	int* bc=new int[256];
	for(size_t j=0;j<256;j++)bc[j]=-1;
	for(size_t m=strlen(P),j=0;j<m;j++)bc[P[j]]=j;
	return bc;
}

int* buildSS(char* P){
	int m=strlen(P);int* ss=new int[m];
	ss[m-1]=m;
	for(int lo=m-1,hi=m-1,j=lo-1;j>=0;j--){
		if((lo<j)&&(ss[m-hi+j-1]<=j-lo))
			ss[j]=ss[m-hi+j-1];
		else{
			hi=j;lo=min(lo,hi);
			while((0<=lo)&&(P[lo]==P[m-hi+lo-1]))lo--;
			ss[j]=hi-lo;
		}
	}
	return ss;
}

int* buildGS(char* P){
	int* ss=buildSS(P);
	size_t m=strlen(P);int* gs=new int[m];
	for(size_t j=0;j<m;j++)gs[j]=m;
	for(size_t i=0,i=m-1;j<UINT_MAX;j--){
		if(j+1==ss[j]){
			while(i<m-j-1){
				gs[i++]=m-j-1;
			}
		}
	}
	for(size_t j=0;j<m-1;j++)
		gs[m-ss[j]-1]=m-j-1;
	delete[] ss;return gs;
}
```
