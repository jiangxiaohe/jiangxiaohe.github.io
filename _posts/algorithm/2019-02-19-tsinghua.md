---
layout: post
title: 清华大学考研机试题目汇总
tags:
- DSA
categories: algorithm
description: 总结考研机试的各种题目
---

# 题型总结

# 2018年
## 1葱的战争
> 一个m*n的棋盘，上面有k根葱，每根葱面朝方向为d（0123分别表示上下左右），每根葱一个战斗力f。每隔时间葱会向面朝方向走一格， 如果遇到棋盘边界，那么他将把面朝方向转180度（此回合葱不会走动），如果某个时刻有两个或以上的葱在同一位置，那么他们将发生战争，只有战斗力最高的葱存活，其他的葱全部原地枯萎，不在走动，求经过t时间后所有葱的位置。

> 输入：第一行m n k，然后接下来k行每根葱的信息x y d f（坐标，方向，战斗力），最后一行输入时间t。\
> 输出：k行，分别表示每个葱的位置。\
> 数据范围：m和n在100内，k在1000内，t在1000内，f在1000内，保证初始每颗葱位置不同，战斗力不同。

思路：建立葱类和葱类的列表，每次移动后需要判断是否相遇，需要考虑的情况是1追击2相遇，设定情况1下不发生战争，情况2下发生战争。

写成类的话更加方便清晰。

```cpp
class Cong {
public:
	static int m, n;//棋盘大小
	//一维数组指针，元素的秩为（y*m+x），表示棋盘各个位置的葱的编号，没有时为-1；
	//用空间换时间，可以在O（1）判断出是否发生碰撞
	static int* vis;
	//所有葱的队列向量
	static Cong* congVector;


	int id;//葱在队列中的编号
	int x,y,d,f;//坐标(x对应m，y对应n)、方向、战斗力
	bool alive;//是否存活
	bool gone;// 两个值即可区分两局之间的差异，如果两个对手的gone值相同，即为同一局，否则其中一个还未走过
	Cong():alive(true), gone(false) {}
	void initCong(int _id,int _x,int _y,int _d,int _f){
		id = _id;
		x = _x; y = _y; d = _d; f=_f;
		vis[y*m + x] = _id;
	}
	void beforewalk() {
		if (vis[y*m + x] == id) {
			vis[y*m + x] = -1;
		}
		else {//走之前对手走到了该位置
			Cong& rival = Cong::congVector[vis[y*m + x]];
			if (d - rival.d == 1 || d - rival.d == -1) {//相遇发生战争
				if (f < rival.f) {
					alive = false; return;
				}
				else {
					rival.alive = false; vis[y*m + x] = -1;
				}
			}
		}
	}
	void afterwalk() {//判断位置冲突并解决
		if (vis[y*m+x]!=-1) {//发生位置冲突
			Cong& rival = congVector[vis[y*m + x]];
			if (gone == rival.gone) {//两者在同一局，发生碰撞，战斗力小的死亡
				if (f < rival.f) {
					alive = false;
					vis[y*m + x] = rival.id;
				}
				else {
					rival.alive = false;
					vis[y*m + x] = id;
				}
			}
			else {//对手本局还未行走，可能出现追击和相遇两种情况，但是采取的措施都是暂时占据该位置
				vis[y*m + x] = id;
			}
		}
		else {
			vis[y*m + x] = id;
		}
	}
	void walk() {
		//Cong::printVis();
		beforewalk();//走之前检验是否有葱走到当前位置，排除相遇的情况
		if (!alive)return;

		//行走
		switch(d){
		case 0:if (y == 0)d = 1; else y--; break;
		case 1:if (y == n - 1)d = 0; else y++; break;
		case 2:if (x == m - 1)d = 3; else x++; break;
		case 3:if (x == 0)d = 2; else x--; break;
		}
		gone = !gone;

		//走之后检验相遇的位置
		afterwalk();
	}
	static void printVis() {
		_for(i, 0, n) {
			_for(j, 0, m) {
				printf("%d ", Cong::vis[i*m+j]);
			}
			printf("\n");
		}
		printf("\n");
	}
};
//静态变量必须在类外初始化
int Cong::m = 0;
int Cong::n = 0;
int* Cong::vis = NULL;
Cong* Cong::congVector=NULL;

void init(int _m, int _n, int _k) {
	Cong::m = _m;
	Cong::n = _n;
	Cong::vis = new int[_m*_n];//分配一维数组空间，特别注意这里是【】而非（）
	Cong::congVector=new Cong[_k];//葱队列初始化
	memset(Cong::vis, -1, sizeof(int)*_m*_n);
	//Cong::printVis();
}


int main() {
	freopen("d:\\input.txt","r",stdin);
	int m,n,k;
	cin >> m >> n >> k;
	//Cong init;//用来引用静态变量
	init(m, n, k);
	int x, y, d, f;
	_for(i, 0, k) {
		cin >> x >> y >> d >> f;
		Cong::congVector[i].initCong(i, x, y, d, f);
	}
	int t;
	cin >> t;
	_for(j, 0, t) {
 		_for(i, 0, k) {
			if(Cong::congVector[i].alive)
				Cong::congVector[i].walk();
		}
 		_for(i, 0, k) {
			Cong& tmp = Cong::congVector[i];
			if (tmp.alive)
				printf("%d %d %d %d %d\n",j, tmp.x, tmp.y, tmp.d, tmp.f);
		}
		Cong::printVis();
	}
	Cong::printVis();
	_for(i, 0, k) {
		Cong& tmp = Cong::congVector[i];
		if (tmp.alive)
			printf("%d %d %d %d\n", tmp.x, tmp.y, tmp.d, tmp.f);
	}
	return 0;
}
```

## 2
> 有n个点，每个点有一个权值，每两点间的不同边的个数为他们权值相与得到的值的二进制数字中的1的个数（边为有向边，有第i指向第j，i<j）\
> 求第1个点到第n个点的路径个数（当且仅当不止一条边不同才被称为两条不同的路径），由于数据很大，对991247取模\


> 输入：第1行n，第二行分别试每个点权值\
> 输出：路径个数\
数据范围:n在2e5内，权值大小在1e9内

思路：
* DFS回溯法，注意回溯过程中标记点是否被访问过，设置好递归基，保存路径即可。
* 计算权值相与后1的个数时可用lowbit
* 首先把图表示出来，计算两两之间边的个数，复杂度O(n^2),生成邻接矩阵。从一点开始DFS，是阶乘复杂度。
* 改进：

## 3
> 有一个n个元素的数列,元素的值只能是0 1 2三个数中的一个，定义四种操作\
(1 i x)表示为把第i位替换成x，x也只能是0 1 2三个数中的一个\
(2 i j)表示把第i个数到第j个数所有的元素值加1，并对3取模\
(3 i j)表示把第i个数到第j个数之间的序列的颠倒顺序\
(4 i j)表示查询第i个数到第j个数之间的序列是否存在三个或以上相同数，如果有，输出yes，否则输出no

> 输入：第一行输入n，接下来一行输入n个数，保证是0 1 2中的一个，第三行输入一个数q，表示操作个数，接下来q行输入q种操作\
输出：每次第四次操作时，输出yes或者no\
数据范围：不记得了

思路：
* 树状数组适用的是单点增加区间查询、单点查询区间增加这两种情况，不符合题意。那用什么数据结构呢？

# 2017年

## 1
给定n个数，询问最少选取前x个数，使得这x个数中可以选择m个数，这m个数最大最小值差距不大于k。所有数据<=1e5

## 2
模拟扫雷游戏，输入地图和玩家的操作，要求对每个操作做出回应。

## 3
数论题，给出公式求解，暴力算法可以得到20分。
