---
layout: post
title: 清华大学考研机试题目汇总
tags:
- DSA
categories: algorithm
description: 总结考研机试的各种题目
---

# 题型总结

# 2018年
## 1葱的战争
> 一个m*n的棋盘，上面有k根葱，每根葱面朝方向为d（0123分别表示上下左右），每根葱一个战斗力f。每隔时间葱会向面朝方向走一格， 如果遇到棋盘边界，那么他将把面朝方向转180度（此回合葱不会走动），如果某个时刻有两个或以上的葱在同一位置，那么他们将发生战争，只有战斗力最高的葱存活，其他的葱全部原地枯萎，不在走动，求经过t时间后所有葱的位置。

> 输入：第一行m n k，然后接下来k行每根葱的信息x y d f（坐标，方向，战斗力），最后一行输入时间t。\
> 输出：k行，分别表示每个葱的位置。\
> 数据范围：m和n在100内，k在1000内，t在1000内，f在1000内，保证初始每颗葱位置不同，战斗力不同。

思路：建立葱类和葱类的列表，每次移动后需要判断是否相遇，需要考虑的情况是1追击2相遇，设定情况1下不发生战争，情况2下发生战争。

写成类的话更加方便清晰。

```cpp
#include"pch.h"//VS2017必须包含从头文件
//#include<bits/stdc++.h>//包含全部头文件 POJ不支持
#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cmath>
#include <deque>
#include <vector>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <stack>
#include <set>
using namespace std;

#define MAXN 1002
#define PII pair<int,int>
#define mp make_pair
#define pb push_back
#define M 100
#define inf 0x7fffffff
#define _for(i,lo,hi) for(int i=(lo);i<(hi);i++)
typedef long long LL;


class Cong {
public:
	static int m, n;//棋盘大小
	//一维数组指针，元素的秩为（y*m+x），表示棋盘各个位置的葱的编号，没有时为-1；
	//用空间换时间，可以在O（1）判断出是否发生碰撞
	static int* vis;
	//所有葱的队列向量
	static Cong* congVector;


	int id;//葱在队列中的编号
	int x,y,d,f;//坐标(x对应m，y对应n)、方向、战斗力
	bool alive;//是否存活
	bool gone;// 两个值即可区分两局之间的差异，如果两个对手的gone值相同，即为同一局，否则其中一个还未走过
	Cong():alive(true), gone(false) {}
	void initCong(int _id,int _x,int _y,int _d,int _f){
		id = _id;
		x = _x; y = _y; d = _d; f=_f;
		vis[y*m + x] = _id;
	}
	void beforewalk() {
		if (vis[y*m + x] == id) {
			vis[y*m + x] = -1;
		}
		else {//走之前对手走到了该位置
			Cong& rival = Cong::congVector[vis[y*m + x]];
			if (d - rival.d == 1 || d - rival.d == -1) {//相遇发生战争
				if (f < rival.f) {
					alive = false; return;
				}
				else {
					rival.alive = false; vis[y*m + x] = -1;
				}
			}
		}
	}
	void afterwalk() {//判断位置冲突并解决
		if (vis[y*m+x]!=-1) {//发生位置冲突
			Cong& rival = congVector[vis[y*m + x]];
			if (gone == rival.gone) {//两者在同一局，发生碰撞，战斗力小的死亡
				if (f < rival.f) {
					alive = false;
					vis[y*m + x] = rival.id;
				}
				else {
					rival.alive = false;
					vis[y*m + x] = id;
				}
			}
			else {//对手本局还未行走，可能出现追击和相遇两种情况，但是采取的措施都是暂时占据该位置
				vis[y*m + x] = id;
			}
		}
		else {
			vis[y*m + x] = id;
		}
	}
	void walk() {
		//Cong::printVis();
		beforewalk();//走之前检验是否有葱走到当前位置，排除相遇的情况
		if (!alive)return;

		//行走
		switch(d){
		case 0:if (y == 0)d = 1; else y--; break;
		case 1:if (y == n - 1)d = 0; else y++; break;
		case 2:if (x == m - 1)d = 3; else x++; break;
		case 3:if (x == 0)d = 2; else x--; break;
		}
		gone = !gone;

		//走之后检验相遇的位置
		afterwalk();
	}
	static void printVis() {
		_for(i, 0, n) {
			_for(j, 0, m) {
				printf("%d ", Cong::vis[i*m+j]);
			}
			printf("\n");
		}
		printf("\n");
	}
};
//静态变量必须在类外初始化
int Cong::m = 0;
int Cong::n = 0;
int* Cong::vis = NULL;
Cong* Cong::congVector=NULL;

void init(int _m, int _n, int _k) {
	Cong::m = _m;
	Cong::n = _n;
	Cong::vis = new int[_m*_n];//分配一维数组空间，特别注意这里是【】而非（）
	Cong::congVector=new Cong[_k];//葱队列初始化
	memset(Cong::vis, -1, sizeof(int)*_m*_n);
	//Cong::printVis();
}


int main() {
	freopen("d:\\input.txt","r",stdin);
	int m,n,k;
	cin >> m >> n >> k;
	//Cong init;//用来引用静态变量
	init(m, n, k);
	int x, y, d, f;
	_for(i, 0, k) {
		cin >> x >> y >> d >> f;
		Cong::congVector[i].initCong(i, x, y, d, f);
	}
	int t;
	cin >> t;
	_for(j, 0, t) {
 		_for(i, 0, k) {
			if(Cong::congVector[i].alive)
				Cong::congVector[i].walk();
		}
 		_for(i, 0, k) {
			Cong& tmp = Cong::congVector[i];
			if (tmp.alive)
				printf("%d %d %d %d %d\n",j, tmp.x, tmp.y, tmp.d, tmp.f);
		}
		Cong::printVis();
	}
	Cong::printVis();
	_for(i, 0, k) {
		Cong& tmp = Cong::congVector[i];
		if (tmp.alive)
			printf("%d %d %d %d\n", tmp.x, tmp.y, tmp.d, tmp.f);
	}
	return 0;
}
```

## 2
> 有n个点，每个点有一个权值，每两点间的不同边的个数为他们权值相与得到的值的二进制数字中的1的个数（边为有向边，有第i指向第j，i<j）\
> 求第1个点到第n个点的路径个数（当且仅当不止一条边不同才被称为两条不同的路径），由于数据很大，对991247取模\


> 输入：第1行n，第二行分别试每个点权值\
> 输出：路径个数\
数据范围:n在2e5内，权值大小在1e9内
