

 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
    
    
    
    
    <title>PAT甲级考试最后一题总结 | Dipper</title>


    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Dipper">
    

    
    <!--<%- open_graph({twitter_id: theme.author.twitter, google_plus: theme.author.google_plus}) %>-->

    <meta name="description" content="page.description">
    
    <meta property="og:type" content="article">
    
    <meta property="og:title" content="PAT甲级考试最后一题总结">
    <meta property="og:url" content="/algorithm/2018/04/02/PATadvanced/">
    <meta property="og:site_name" content="Dipper">
    <meta property="og:description" content="笔记">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="PAT甲级考试最后一题总结">
    <meta name="twitter:description" content="page.description">
    <meta name="twitter:creator" content="@">
    <link rel="publisher" href="">

    
    
    <link rel="icon" href="/assets/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/assets/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/assets/img/jacman.jpg">
    

    <link rel="stylesheet" href="/assets/css/main.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/highlight.css" type="text/css">
    
    <style>
        body >header {
            background: url("/assets/img/banner.jpg") center #2ca6cb;
        }
    </style>
    
    
</head>

  <body>
    <header>
        <div>
		    
			<div id="imglogo">
				<a href="/"><img src="/assets/img/dipper_logo.jpg" alt="Dipper" title="Dipper"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Dipper">Dipper</a></h1>
				<h2 class="blog-motto">stay foolish, stay hungry</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/categories">目录</a></li>
					
						<li><a href="/about">关于我</a></li>
					
					<li>
 					
					<form class="search" action="/search" method="get" accept-charset="utf-8">
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>
</div>

    </header>
    <div id="container">
      



<div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
	<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/algorithm/2018/04/02/PATadvanced/" title="PAT甲级考试最后一题总结" itemprop="url">PAT甲级考试最后一题总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dipper" target="_blank" itemprop="author">Dipper</a>
		
  <p class="article-time">
    <time datetime="2018-04-02 00:00:00 +0800" itemprop="datePublished"> 发表于 2018-04-02</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article toc-content" style="display: none;">
		
			<!--<%- toc(item.content) %>-->
		
		</div>
		
		<h1 id="1004-counting-leaves树遍历">1004 Counting Leaves[树遍历]</h1>
<p>给定一颗树，问每一层各有多少叶子结点。</p>

<p>采用邻接表的方式存储该树，用一个标志数组表示该层结束最方便。如果节点不多，并且序号连续固定（本题），可以用一个level数组来表示，记录每个节点的层次。
采用DFS或BFS的方法均可，DFS如果深度不大优先选取，因为代码较简洁。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX 105
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">MAX</span><span class="p">);</span><span class="c1">//存储树
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">(</span><span class="n">MAX</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//节点的层数，0节点层数为0；
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">levNum</span><span class="p">(</span><span class="n">MAX</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//该层叶子结点数目
</span><span class="kt">int</span> <span class="n">maxLev</span><span class="p">;</span>
<span class="cp">#define _for(i,a,b) for(int i=(a);i&lt;(b);i++)
</span><span class="kt">int</span> <span class="n">getint</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="kt">int</span> <span class="n">lev</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">levNum</span><span class="p">[</span><span class="n">level</span><span class="p">[</span><span class="n">id</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">lev</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;</span><span class="n">maxLev</span><span class="p">)</span><span class="n">maxLev</span><span class="o">=</span><span class="n">lev</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">size</span><span class="p">()){</span>
			<span class="n">DFS</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">level</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">lev</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="c1">//freopen("D:\\input.txt","r",stdin);
</span>	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="n">k</span><span class="p">;</span><span class="c1">//后继个数、临时变量
</span>	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
			<span class="n">_for</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">){</span>
				<span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">getint</span><span class="p">());</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//DFS
</span>	<span class="n">maxLev</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">DFS</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">levNum</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">maxLev</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">" %d"</span><span class="p">,</span><span class="n">levNum</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1014-waiting-in-line模拟">1014 Waiting in Line[模拟]</h1>
<p>某银行有N个窗口，每个窗口前可以排M个人。现在有K个客户需要服务，每位客户的服务时长已知。假设所有客户在8:00按客户编号次序排在黄线外，每个窗口的人数少于M时，黄线外的客户就去补齐。给出Q个查询，输出查询客户的办理结束时间。</p>

<p>模拟，用数组记录每个客户的办理开始时间，用分钟记录，如果该客户的开始时间在17:00及以后，则不予办理。</p>

<p>易错点：Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output Sorry instead.这句话含义不清楚啊，导致三个算例没过，be servered原来指的是开始服务的时间，很容易当做是结束服务的时间，从而导致出错.其实用脑子想象也应该不是结束服务的时间，总不能服务一半吧</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这个代码看起来太繁杂了，用优先级队列看起来更好。但是本题中只有20个窗口，每次选择最小窗口时，直接遍历两次更加简单。本代码中给每个窗口包含一个队列，采用了静态数组队列的方法，其实不如用stl的队列，则写起来更加简洁。
</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="c1">//freopen("d:\\input.txt","r",stdin);
</span>	<span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">Q</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">N</span><span class="p">,</span><span class="o">&amp;</span><span class="n">M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">);</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">process</span><span class="p">(</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="c1">//process[i]是id=i的顾客办理业务所花时间
</span>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">time</span><span class="p">(</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="c1">//time[i]是id=i的顾客办理完业务的时间，其实记录开始时间更好，就不用下面的vis数组了
</span>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">(</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span><span class="c1">//vis[i]表示id=i的顾客可以被服务
</span>	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">process</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">myq</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1005</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span> <span class="c1">//黄线以内的队列,为了记录历史队列信息，用数组模拟队
</span>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">front</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">back</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//记录各个队列的队首和队尾，[front,back)，队空是front==back,队中元素个数为back-front
</span>
	<span class="c1">//初始化，所有黄线内队列入满
</span>	<span class="kt">int</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="c1">//1号客户准备入队
</span>	<span class="k">while</span><span class="p">(</span><span class="n">back</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">front</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&amp;&amp;</span><span class="n">id</span><span class="o">&lt;=</span><span class="n">K</span><span class="p">){</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">){</span>
			<span class="c1">//printf("i=%d front=%d back=%d\n",i,front[i],back[i]);
</span>			<span class="k">if</span><span class="p">(</span><span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">front</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&amp;&amp;</span><span class="n">id</span><span class="o">&lt;=</span><span class="n">K</span><span class="p">){</span>
				<span class="c1">//一旦入队，办理业务的时间也就确定了
</span>				<span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="n">time</span><span class="p">[</span><span class="n">myq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]];</span>
				<span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">17</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span><span class="n">vis</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
				<span class="n">time</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">=</span><span class="n">tmp</span><span class="o">+</span><span class="n">process</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
				<span class="c1">//printf("time[%d]=%d\n",id,time[id]);
</span>				<span class="n">myq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">id</span><span class="p">;</span>
				<span class="c1">//printf("i=%d id=%d\n",i,id);
</span>				<span class="n">id</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">while</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;=</span><span class="n">K</span><span class="p">){</span><span class="c1">//说明黄线外队列还有人，需要模拟出队
</span>		<span class="c1">//遍历队首，让最早办完的人出队
</span>		<span class="kt">int</span> <span class="n">minque</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">myq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">front</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span><span class="o">&lt;</span><span class="n">time</span><span class="p">[</span><span class="n">myq</span><span class="p">[</span><span class="n">minque</span><span class="p">][</span><span class="n">front</span><span class="p">[</span><span class="n">minque</span><span class="p">]]])</span><span class="n">minque</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">front</span><span class="p">[</span><span class="n">minque</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="c1">//printf("minque=%d\n",minque);
</span>		<span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="n">back</span><span class="p">[</span><span class="n">minque</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="n">time</span><span class="p">[</span><span class="n">myq</span><span class="p">[</span><span class="n">minque</span><span class="p">][</span><span class="n">back</span><span class="p">[</span><span class="n">minque</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">17</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span><span class="n">vis</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
		<span class="n">time</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">=</span><span class="n">tmp</span><span class="o">+</span><span class="n">process</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
		<span class="c1">//printf("time[%d]=%d\n",id,time[id]);
</span>		<span class="n">myq</span><span class="p">[</span><span class="n">minque</span><span class="p">][</span><span class="n">back</span><span class="p">[</span><span class="n">minque</span><span class="p">]</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">id</span><span class="p">;</span>
		<span class="n">id</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">Q</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">id</span><span class="p">]){</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"%02d:%02d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">time</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">/</span><span class="mi">60</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span><span class="n">time</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">%</span><span class="mi">60</span><span class="p">);</span>
		<span class="p">}</span><span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Sorry</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1018-public-bike-management最短路径">1018 Public Bike Management[最短路径]</h1>
<p>城市里有一些公共自行车站，每个车站的自行车最大容量为一个偶数Cmax，且如果一个车站中自行车的数量恰好是Cmax/2，那额称该车站处于完美状态。而如果一个车站是满的或空的，那么控制中心PBMC就会携带或从路上手机一定数量的自行车前往该车站，以使该问题车站都达到完美状态。现在给出Cmax，车站数目N（不含控制中心），问题车站编号Sp，无向边数M及边权，求一条从PBMC到达问题车站的最短路径，输出需要从PBMC携带的自行车数目、最短路径、到达问题车站后需要带回的自行车数目。如果路径有多条，选择从PBMC带回的自行车数目最少的，如果仍然有多条，那么选择最后从问题车站带回的自行车数目最少的。注意：沿途所有车站的调整过程必须在前往问题车站的过程中就调整完毕，带回时不再调整。</p>

<p>Dijkstra记录所有的最短路径，然后DFS找出符合条件的最短路径。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span><span class="p">{</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">len</span><span class="p">;</span><span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">xx</span><span class="p">,</span><span class="kt">int</span> <span class="n">ll</span><span class="p">)</span><span class="o">:</span><span class="n">x</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span><span class="n">len</span><span class="p">(</span><span class="n">ll</span><span class="p">){}};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">MAX</span><span class="p">);</span><span class="c1">//节点标号为1-N,从0出发
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">path</span><span class="p">(</span><span class="n">MAX</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">,</span><span class="n">minpath</span><span class="p">;</span><span class="c1">//记录中间路径,最短路径
</span><span class="kt">int</span> <span class="n">minwei</span><span class="o">=</span><span class="n">inf</span><span class="p">,</span><span class="n">minremain</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">Cmax</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">Sp</span><span class="p">,</span><span class="n">M</span><span class="p">;</span><span class="c1">//含义与题目同
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">MAX</span><span class="p">,</span><span class="n">inf</span><span class="p">),</span><span class="n">vis</span><span class="p">(</span><span class="n">MAX</span><span class="p">,</span><span class="nb">false</span><span class="p">),</span><span class="n">weight</span><span class="p">(</span><span class="n">MAX</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">Dijkstra</span><span class="p">(){</span><span class="c1">//x顶点到其他定点的单源最短路径
</span>	<span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="n">len</span><span class="p">,</span><span class="n">n</span><span class="p">;</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">id</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span><span class="n">len</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span>
		<span class="c1">//找到未发现的定点中的最近顶点，加入已发现集合
</span>		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">len</span><span class="p">){</span>
				<span class="n">len</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">id</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span><span class="k">return</span><span class="p">;</span>
		<span class="c1">//从该定点更新状态数组
</span>		<span class="n">vis</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
		<span class="n">n</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
		<span class="kt">int</span> <span class="n">nextid</span><span class="p">;</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">){</span>
			<span class="n">nextid</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span><span class="n">len</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span><span class="c1">//分别表示顶点和长度
</span>			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">nextid</span><span class="p">]){</span>
				<span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">nextid</span><span class="p">]</span><span class="o">&gt;</span><span class="n">dist</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">){</span>
					<span class="n">dist</span><span class="p">[</span><span class="n">nextid</span><span class="p">]</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">;</span>
					<span class="n">path</span><span class="p">[</span><span class="n">nextid</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
					<span class="n">path</span><span class="p">[</span><span class="n">nextid</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
				<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">nextid</span><span class="p">]</span><span class="o">==</span><span class="n">dist</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">){</span>
					<span class="n">path</span><span class="p">[</span><span class="n">nextid</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">//遍历path向量，在最短路径中寻找
//这里每个节点需要两个标记，到达该节点需要带来的数目，从该节点需要带走的数目
//两者可能均不为0，比如前两个节点为-5，10，从0节点出发需要带5个，而从2节点返回时带10个，返回到0节点也要带上这10个
</span><span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="kt">int</span> <span class="n">wei</span><span class="p">,</span><span class="kt">int</span> <span class="n">remain</span><span class="p">){</span><span class="c1">//Wei表示在id节点需要带来的数目，remain表示在id节点需要带走的数目
</span>	<span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">wei</span><span class="o">&lt;</span><span class="n">minwei</span><span class="p">){</span>
			<span class="n">minwei</span><span class="o">=</span><span class="n">wei</span><span class="p">;</span>
			<span class="n">minremain</span><span class="o">=</span><span class="n">remain</span><span class="p">;</span>
			<span class="n">minpath</span><span class="o">=</span><span class="n">vec</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">wei</span><span class="o">==</span><span class="n">minwei</span><span class="o">&amp;&amp;</span><span class="n">remain</span><span class="o">&lt;</span><span class="n">minremain</span><span class="p">){</span>
			<span class="n">minremain</span><span class="o">=</span><span class="n">remain</span><span class="p">;</span>
			<span class="n">minpath</span><span class="o">=</span><span class="n">vec</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">path</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">size</span><span class="p">()){</span>
		<span class="kt">int</span> <span class="n">next</span><span class="o">=</span><span class="n">path</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
		<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">wei</span><span class="p">)</span>
				<span class="n">DFS</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">remain</span><span class="o">+</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">-</span><span class="n">wei</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">DFS</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="n">wei</span><span class="o">-</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">],</span><span class="n">remain</span><span class="p">);</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">DFS</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="n">wei</span><span class="o">-</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">],</span><span class="n">remain</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//freopen("d:\\input.txt","r",stdin);
</span>    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Cmax</span><span class="p">,</span><span class="o">&amp;</span><span class="n">N</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Sp</span><span class="p">,</span><span class="o">&amp;</span><span class="n">M</span><span class="p">);</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">getint</span><span class="p">()</span><span class="o">-</span><span class="n">Cmax</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="c1">//输入时直接减去，后面可根据其正负判断
</span>	<span class="p">}</span>
    <span class="kt">int</span> <span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">len</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">M</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c2</span><span class="p">,</span><span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">c1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span><span class="n">len</span><span class="p">));</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">c2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">len</span><span class="p">));</span>
    <span class="p">}</span>
	<span class="c1">//从0节点计算单源最短路径
</span>	<span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">Dijkstra</span><span class="p">();</span>
	<span class="c1">//测试中居然还存在Sp节点不是问题节点的情况，所以，初始化进入DFS要分此两种情况
</span>	<span class="k">if</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">Sp</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">DFS</span><span class="p">(</span><span class="n">Sp</span><span class="p">,</span><span class="o">-</span><span class="n">weight</span><span class="p">[</span><span class="n">Sp</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">DFS</span><span class="p">(</span><span class="n">Sp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">weight</span><span class="p">[</span><span class="n">Sp</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="n">minwei</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">minpath</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d-&gt;"</span><span class="p">,</span><span class="n">minpath</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="n">Sp</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">minremain</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1022">1022</h1>
<h1 id="1026-table-tennis模拟">1026 Table Tennis[模拟]</h1>
<p>有K张乒乓球桌（编号1-K）于8:00-21:00开放，每对球员到达时总是选择当前空闲的最小球桌进行训练，且训练时长超过2h的会被强制压缩为2h，如果到达的时候没有球桌空闲，则排队等待。使问题复杂的地方在于，这K张球桌里面有M张是VIP球桌，如果存在VIP球桌空闲，且排队等待队列中存在VIP球员，那么等待队列汇总的第一对VIP球员将前往编号最小的VIP球桌进行训练；如果等待队列中没有VIP球员，那么VIP球桌被当做普通球桌处理；如果当前没有VIP球桌空闲，那么VIP球员将被当做普通球员处理。</p>

<p>输出每对球员的到达时间，结束时间和等待时间。</p>

<p>如果不存在VIP球桌，这个题目就和1014一模一样了，相当于1014中的窗口队列大小为1。因为存在VIP球桌，对其单独处理即可。</p>

<p>先按照到达时间给球桌初始化，然后遍历球桌找到结束时间最早的球桌进行处理，然后判断该球桌是否是VIP以及队列中是否有VIP球员。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">person</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arrive</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">time</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">vip</span><span class="p">;</span>
<span class="p">}</span><span class="n">tempperson</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tablenode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">,</span> <span class="n">num</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">vip</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="nf">cmp1</span><span class="p">(</span><span class="n">person</span> <span class="n">a</span><span class="p">,</span> <span class="n">person</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">arrive</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">arrive</span><span class="p">;}</span>
<span class="kt">bool</span> <span class="nf">cmp2</span><span class="p">(</span><span class="n">person</span> <span class="n">a</span><span class="p">,</span> <span class="n">person</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">start</span><span class="p">;}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">person</span><span class="o">&gt;</span> <span class="n">player</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">tablenode</span><span class="o">&gt;</span> <span class="n">table</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">alloctable</span><span class="p">(</span><span class="kt">int</span> <span class="n">personid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tableid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">player</span><span class="p">[</span><span class="n">personid</span><span class="p">].</span><span class="n">arrive</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="n">tableid</span><span class="p">].</span><span class="n">end</span><span class="p">)</span>
        <span class="n">player</span><span class="p">[</span><span class="n">personid</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">tableid</span><span class="p">].</span><span class="n">end</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">player</span><span class="p">[</span><span class="n">personid</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">player</span><span class="p">[</span><span class="n">personid</span><span class="p">].</span><span class="n">arrive</span><span class="p">;</span>
    <span class="n">table</span><span class="p">[</span><span class="n">tableid</span><span class="p">].</span><span class="n">end</span> <span class="o">=</span> <span class="n">player</span><span class="p">[</span><span class="n">personid</span><span class="p">].</span><span class="n">start</span> <span class="o">+</span> <span class="n">player</span><span class="p">[</span><span class="n">personid</span><span class="p">].</span><span class="n">time</span><span class="p">;</span>
    <span class="n">table</span><span class="p">[</span><span class="n">tableid</span><span class="p">].</span><span class="n">num</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//该函数可以简单的表示出当前队列中是否有VIP存在
</span><span class="kt">int</span> <span class="nf">findnextvip</span><span class="p">(</span><span class="kt">int</span> <span class="n">vipid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vipid</span><span class="o">++</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">vipid</span> <span class="o">&lt;</span> <span class="n">player</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">player</span><span class="p">[</span><span class="n">vipid</span><span class="p">].</span><span class="n">vip</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="n">vipid</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">vipid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">viptable</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">temptime</span><span class="p">,</span> <span class="n">flag</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d:%d:%d %d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temptime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flag</span><span class="p">);</span>
        <span class="n">tempperson</span><span class="p">.</span><span class="n">arrive</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">3600</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">tempperson</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">21</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tempperson</span><span class="p">.</span><span class="n">arrive</span> <span class="o">&gt;=</span> <span class="mi">21</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">tempperson</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">temptime</span> <span class="o">&lt;=</span> <span class="mi">120</span> <span class="o">?</span> <span class="n">temptime</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">:</span> <span class="mi">7200</span><span class="p">;</span>
        <span class="n">tempperson</span><span class="p">.</span><span class="n">vip</span> <span class="o">=</span> <span class="p">((</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">);</span>
        <span class="n">player</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tempperson</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="n">table</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">viptable</span><span class="p">);</span>
        <span class="n">table</span><span class="p">[</span><span class="n">viptable</span><span class="p">].</span><span class="n">vip</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">player</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">player</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vipid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">vipid</span> <span class="o">=</span> <span class="n">findnextvip</span><span class="p">(</span><span class="n">vipid</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">player</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">minendtime</span> <span class="o">=</span> <span class="mi">999999999</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">minendtime</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">minendtime</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">end</span><span class="p">;</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="mi">21</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vip</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vipid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">vip</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vip</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">alloctable</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">vipid</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="n">vipid</span> <span class="o">=</span> <span class="n">findnextvip</span><span class="p">(</span><span class="n">vipid</span><span class="p">);</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">vipid</span> <span class="o">&lt;</span> <span class="n">player</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">player</span><span class="p">[</span><span class="n">vipid</span><span class="p">].</span><span class="n">arrive</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">alloctable</span><span class="p">(</span><span class="n">vipid</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                    <span class="n">vipid</span> <span class="o">=</span> <span class="n">findnextvip</span><span class="p">(</span><span class="n">vipid</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">alloctable</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vip</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">alloctable</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">vipindex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">minvipendtime</span> <span class="o">=</span> <span class="mi">999999999</span><span class="p">;</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">vip</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">minvipendtime</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">minvipendtime</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">end</span><span class="p">;</span>
                        <span class="n">vipindex</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span><span class="n">vipindex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arrive</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="p">[</span><span class="n">vipindex</span><span class="p">].</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">alloctable</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vipindex</span><span class="p">);</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">vipid</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="n">vipid</span> <span class="o">=</span> <span class="n">findnextvip</span><span class="p">(</span><span class="n">vipid</span><span class="p">);</span>
                    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">alloctable</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">vipid</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="n">vipid</span> <span class="o">=</span> <span class="n">findnextvip</span><span class="p">(</span><span class="n">vipid</span><span class="p">);</span>
                    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">player</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">player</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp2</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">player</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">21</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%02d:%02d:%02d "</span><span class="p">,</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arrive</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">,</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arrive</span> <span class="o">%</span> <span class="mi">3600</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arrive</span> <span class="o">%</span> <span class="mi">60</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%02d:%02d:%02d "</span><span class="p">,</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">,</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">%</span> <span class="mi">3600</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">%</span> <span class="mi">60</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%.0f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">round</span><span class="p">((</span><span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">-</span> <span class="n">player</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arrive</span><span class="p">)</span> <span class="o">/</span> <span class="mf">60.0</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1030-travel-plan最短路径">1030 Travel Plan[最短路径]</h1>
<p>有N个城市（编号0~N-1）,M条道路（无向边），并给出M条道路的距离属性与花费属性。现在给定起点S与终点D，求从起点到终点的最短路径、最短距离及花费。注意如果有多条最短路径，则选择花费最小的那条。</p>

<p>典型的Dijkstra+第二边权的问题，保存另一个数组记录到该点的花费即可。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
     <span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="n">dist</span><span class="p">,</span><span class="n">cost</span><span class="p">;</span><span class="c1">//可到达的下一个顶点和边权
</span>     <span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">rr</span><span class="p">,</span><span class="kt">int</span> <span class="n">dd</span><span class="p">,</span><span class="kt">int</span> <span class="n">cc</span><span class="p">)</span><span class="o">:</span><span class="n">r</span><span class="p">(</span><span class="n">rr</span><span class="p">),</span><span class="n">dist</span><span class="p">(</span><span class="n">dd</span><span class="p">),</span><span class="n">cost</span><span class="p">(</span><span class="n">cc</span><span class="p">){}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//freopen("D:\\input.txt","r",stdin);
</span>    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c2</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">w</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//所有前驱节点的第二维度和
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">inf</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//记录最短路径的数目
</span>
    <span class="kt">int</span> <span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">t3</span><span class="p">,</span><span class="n">t4</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t2</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t3</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t4</span><span class="p">);</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">t1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">t3</span><span class="p">,</span><span class="n">t4</span><span class="p">));</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">t2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">t3</span><span class="p">,</span><span class="n">t4</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">num</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//每次循环，添加进一个节点，由于令dist[c1]为0，而其他均为inf，首先进入的节点必为c1
</span>        <span class="kt">int</span> <span class="n">id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">dis</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span><span class="c1">//下一个最近节点的id和距离
</span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">dis</span><span class="p">){</span><span class="n">dis</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="n">id</span><span class="o">=</span><span class="n">j</span><span class="p">;}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//说明非连通图
</span>        <span class="n">vis</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">r</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">dist</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">d</span><span class="o">!=</span><span class="n">inf</span><span class="p">){</span>

                <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="o">&lt;</span><span class="n">dist</span><span class="p">[</span><span class="n">r</span><span class="p">]){</span>
                    <span class="n">path</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">=</span><span class="n">id</span><span class="p">;</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="p">;</span>
                    <span class="n">w</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">c</span><span class="p">;</span>
                    <span class="n">num</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">=</span><span class="n">num</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="o">==</span><span class="n">dist</span><span class="p">[</span><span class="n">r</span><span class="p">]){</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">&gt;</span><span class="n">w</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">c</span><span class="p">){</span>
                        <span class="n">w</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">c</span><span class="p">;</span>
                        <span class="n">path</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">=</span><span class="n">id</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">num</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">+=</span><span class="n">num</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="c1">//找到相同长度的线路
</span>                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printpath</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span><span class="n">path</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="n">dist</span><span class="p">[</span><span class="n">c2</span><span class="p">],</span><span class="n">w</span><span class="p">[</span><span class="n">c2</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1034-head-of-a-gangbfs图遍历">1034 Head of a Gang[BFS图遍历]</h1>
<p>给出若干人的通话长度（视为无向边），按照这些通话将他们分为若干个组。每个组的总边权设为该组内的所有通话的长度之和，而每个人的点权设为该人参与的通话长度之和。现在给定一个阈值K，且只要一个组的总边权超过K，并满足成员人数超过2，则将该组视为“Gang”，而该组内点权最大的人视为头目。要求输出Gang的个数，并按照头目姓名字典序从小到大的顺序输出每个Gang的头目姓名和成员人数。</p>

<p>BFS遍历获得连通块的个数以及总边权和头目、成员人数。名字与节点的对应关系map，最后答案要求按照字母序，显然用map</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//freopen("D:\\input.txt","r",stdin);
</span>    <span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">K</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">N</span><span class="p">,</span><span class="o">&amp;</span><span class="n">K</span><span class="p">);</span>
    <span class="c1">//定义邻接表的最简单方法，最多有2*N个节点
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">];</span><span class="c1">//这个写法就是邻接表的另外一种表达
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">weight</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">//名字与节点序号的对应关系用map和向量实现
</span>    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">str2num</span><span class="p">;</span><span class="kt">int</span> <span class="n">hashrank</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//记录成员的个数
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">num2str</span><span class="p">;</span>
    <span class="c1">//记录答案
</span>    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>

    <span class="n">string</span> <span class="n">name1</span><span class="p">,</span><span class="n">name2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">time</span><span class="p">;</span>
    <span class="c1">//初始化
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">name1</span><span class="o">&gt;&gt;</span><span class="n">name2</span><span class="o">&gt;&gt;</span><span class="n">time</span><span class="p">;</span><span class="c1">//这里用cin也是没问题的
</span>        <span class="c1">//下面写为getID更好
</span>        <span class="k">if</span><span class="p">(</span><span class="n">str2num</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">name1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
            <span class="n">str2num</span><span class="p">[</span><span class="n">name1</span><span class="p">]</span><span class="o">=</span><span class="n">hashrank</span><span class="o">++</span><span class="p">;</span><span class="n">num2str</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">name1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">str2num</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">name2</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span><span class="n">str2num</span><span class="p">[</span><span class="n">name2</span><span class="p">]</span><span class="o">=</span><span class="n">hashrank</span><span class="o">++</span><span class="p">;</span><span class="n">num2str</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">name2</span><span class="p">);}</span>
        <span class="kt">int</span> <span class="n">t1</span><span class="o">=</span><span class="n">str2num</span><span class="p">[</span><span class="n">name1</span><span class="p">],</span><span class="n">t2</span><span class="o">=</span><span class="n">str2num</span><span class="p">[</span><span class="n">name2</span><span class="p">];</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">t1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span><span class="n">weight</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span><span class="o">+=</span><span class="n">time</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">t2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span><span class="n">weight</span><span class="p">[</span><span class="n">t2</span><span class="p">]</span><span class="o">+=</span><span class="n">time</span><span class="p">;</span>
   <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">finded</span><span class="p">(</span><span class="n">hashrank</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
    <span class="c1">//BFS图遍历，在图遍历的过程中记录权值最大的点、成员个数和通话时间总和
</span>    <span class="c1">//和一般的BFS不同之处就是就加入了对于图中节点的处理
</span>    <span class="kt">int</span> <span class="n">gangnum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//满足题意的连通域总数
</span>    <span class="kt">int</span> <span class="n">sub_sum</span><span class="p">,</span><span class="n">sub_id</span><span class="p">,</span><span class="n">sub_p</span><span class="p">;</span><span class="c1">//分别记录连通域的权值\最大值的id\成员个数
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">hashrank</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">finded</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span><span class="c1">//发现新连通域
</span>            <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span><span class="c1">//DFS队列
</span>            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">finded</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span><span class="n">sub_sum</span><span class="o">=</span><span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">sub_id</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">sub_p</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
                <span class="n">cur</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
                    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">finded</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">j</span><span class="p">]]){</span>
                        <span class="n">finded</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
                        <span class="n">sub_sum</span><span class="o">+=</span><span class="n">weight</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">j</span><span class="p">]];</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span><span class="o">&gt;</span><span class="n">weight</span><span class="p">[</span><span class="n">sub_id</span><span class="p">])</span><span class="n">sub_id</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                        <span class="n">sub_p</span><span class="o">++</span><span class="p">;</span>
                        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">//cout&lt;&lt;num2str[i]&lt;&lt;" "&lt;&lt;weight[i]&lt;&lt;" "&lt;&lt;sub_p&lt;&lt;" "&lt;&lt;sub_sum&lt;&lt;endl;
</span>            <span class="k">if</span><span class="p">(</span><span class="n">sub_p</span><span class="o">&gt;</span><span class="mi">2</span><span class="o">&amp;&amp;</span><span class="n">sub_sum</span><span class="o">/</span><span class="mi">2</span><span class="o">&gt;</span><span class="n">K</span><span class="p">){</span>
                <span class="n">gangnum</span><span class="o">++</span><span class="p">;</span><span class="c1">//连通域个数
</span>                <span class="n">ans</span><span class="p">[</span><span class="n">num2str</span><span class="p">[</span><span class="n">sub_id</span><span class="p">]]</span><span class="o">=</span><span class="n">sub_p</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">gangnum</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">ans</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">!=</span><span class="n">ans</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1038">1038</h1>
<h1 id="1045-favorite-color-stripe动态规划">1045 Favorite Color Stripe[动态规划]</h1>
<p>给出m中颜色作为主人公EVA喜欢的颜色以及顺序，然后给出一串长度为L的颜色序列。现在要除掉这个序列中EVA不喜欢的颜色，然后求剩余序列的一个子序列，使得这个子序列表示的颜色顺序符合EVA喜欢的颜色的顺序，且为所有满足这个条件的子序列中长度最长的子序列。</p>

<p>先将eva喜欢的颜色{2,3,1,5,6}映射为{0,1,2,3,4},可以在读入颜色序列的时候将不存在喜欢颜色中的不存入待处理序列。然后按照最长不下降子序列的方法处理就好。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
     <span class="c1">//freopen("d:\\CodeBlockSpace\\input.txt","r",stdin);
</span>     <span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">l</span><span class="p">;</span>
     <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
     <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
     <span class="kt">int</span> <span class="n">pri</span><span class="p">[</span><span class="mi">201</span><span class="p">];</span><span class="n">memset</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">201</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
     <span class="c1">//设置排序大小，不在喜欢列表中的元素为0
</span>     <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
     <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span><span class="n">pri</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;}</span>
     <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
     <span class="kt">int</span><span class="o">*</span> <span class="n">num</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
     <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">l</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>

     <span class="c1">//dp[i]表示以i结尾的最长不降子序列的长度
</span>     <span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
     <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
     <span class="k">while</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
     <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">_max</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
     <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">l</span><span class="p">){</span>
         <span class="k">if</span><span class="p">(</span><span class="n">pri</span><span class="p">[</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
         <span class="k">else</span><span class="p">{</span>
             <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
             <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
                 <span class="k">if</span><span class="p">(</span><span class="n">pri</span><span class="p">[</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">&gt;=</span><span class="n">pri</span><span class="p">[</span><span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
             <span class="p">}</span>
         <span class="p">}</span>
        <span class="n">_max</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">_max</span><span class="p">,</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">_max</span><span class="p">);</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
<span class="c1">//只将合法元素插入到序列中
</span>	<span class="c1">//freopen("D:\\input.txt","r",stdin);
</span>	<span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">maxsum</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hashtable</span><span class="p">(</span><span class="mi">205</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">,</span><span class="n">dp</span><span class="p">(</span><span class="mi">10005</span><span class="p">);</span><span class="c1">//dp[i]表示以i为后缀的最长不下降子序列的长度
</span>	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">N</span><span class="p">;</span>
	<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mmap</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">M</span><span class="p">;</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">M</span><span class="p">){</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">;</span><span class="n">hashtable</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;}</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">M</span><span class="p">;</span>
	<span class="c1">//剔除掉不喜欢的元素，然后按照最大递增子序列来做最方便
</span>	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>	<span class="p">{</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">;</span><span class="k">if</span><span class="p">(</span><span class="n">hashtable</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">hashtable</span><span class="p">[</span><span class="n">t</span><span class="p">]);}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">"0"</span><span class="p">);</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
	<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
		<span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="c1">//这里一定要赋初值1，否则会错误很多
</span>		<span class="n">_for</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">maxsum</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">maxsum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">maxsum</span><span class="p">);</span>

</code></pre></div></div>

<h1 id="1049">1049</h1>

<h1 id="1053-path-of-equal-weight树遍历">1053 Path of Equal Weight[树遍历]</h1>
<p>给定一颗树和每个节点的权值，求所有从根节点到叶子节点的路径，使得每条路径上节点的权值之和等于给定的常数S。</p>

<p>同1004中树的存储方式，采用邻接表即可。因为题目需要存储路径，所以用DFS回溯，可以用数组存储路径，用push和pop的方法或者采用全局节点秩的方法。</p>

<p>注意，本题对于结果有字典序的要求，在DFS之前，将所有节点的孩子数组从小到大排列，然后DFS即可。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX 105
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span><span class="c1">//记录答案
</span>
<span class="c1">//直接在这里定义节点数组，对于内部的孩子节点vector,可调用sort对其进行排序
</span><span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">;</span><span class="c1">//权值
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">child</span><span class="p">;</span>
<span class="p">}</span><span class="n">Node</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>

<span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sta</span><span class="p">,</span><span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">w</span><span class="o">==</span><span class="n">key</span><span class="p">){</span>
            <span class="n">sta</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">w</span><span class="p">);</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
            <span class="n">sta</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sta</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">w</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">key</span><span class="o">&gt;=</span><span class="n">Node</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">w</span><span class="p">)</span><span class="n">DFS</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">sta</span><span class="p">,</span><span class="n">key</span><span class="o">-</span><span class="n">Node</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">sta</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">Node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">w</span><span class="o">&gt;</span><span class="n">Node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">w</span><span class="p">;}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//freopen("d:\\input.txt","r",stdin);
</span>    <span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">Key</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">N</span><span class="p">,</span><span class="o">&amp;</span><span class="n">M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Key</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span><span class="o">!=</span><span class="n">EOF</span><span class="p">){</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
            <span class="n">Node</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">child</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//因为这里是按照节点权值大小进行排序，所以要引入自定义排序函数cmp
</span>        <span class="n">sort</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">child</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">Node</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">child</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">cmp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//根据题意，0节点为根节点
</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ch</span><span class="p">;</span><span class="c1">//用向量模拟栈，进行深度优先搜索
</span>    <span class="n">DFS</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">ch</span><span class="p">,</span><span class="n">Key</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1057-stack树状数组">1057 Stack[树状数组]</h1>
<p>给出一个栈的入栈、出栈的过程，并随时通过PeekMedian要求输出栈中中位数。</p>

<p>注意到输入栈的数字均为正整数且&lt;=10^5，所以可以用树状数组来表示每个数字的个数。当PeekMedian命令时，因为树状数组存储的是各个数字的个数，用二分法找到getSum()&gt;=N/2的最小数即可。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span><span class="o">=</span><span class="mi">100005</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span><span class="n">C</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
<span class="cp">#define lowbit(i) (i&amp;(-i))
</span>
<span class="c1">//A[x]加上v
</span><span class="kt">void</span> <span class="n">updata</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="k">return</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">MAXN</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">)){</span>
		<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">v</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//计算A[1]-A[x]的和
</span><span class="kt">int</span> <span class="n">getsum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">-=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">)){</span>
		<span class="n">sum</span><span class="o">+=</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">getmid</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="c1">//求getsum(i)&gt;=k的最小值
</span>	<span class="kt">int</span> <span class="n">lo</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">hi</span><span class="o">=</span><span class="n">MAXN</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">hi</span><span class="p">){</span><span class="c1">//[lo,hi)
</span>		<span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="n">hi</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">getsum</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">k</span><span class="p">){</span>
			<span class="n">hi</span><span class="o">=</span><span class="n">mid</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">lo</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">lo</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//freopen("d:\\input.txt","r",stdin);
</span>	<span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">N</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">op</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">top</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="n">op</span><span class="p">);</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]){</span>
		<span class="k">case</span> <span class="sc">'u'</span><span class="p">:</span>
			<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
			<span class="c1">//A[t]++;
</span>			<span class="n">updata</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="n">top</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'o'</span><span class="p">:</span>
			<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="n">printf</span><span class="p">(</span><span class="s">"Invalid</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">t</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
				<span class="c1">//A[t]--;
</span>				<span class="n">updata</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'e'</span><span class="p">:</span>
			<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="n">printf</span><span class="p">(</span><span class="s">"Invalid</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
			<span class="k">else</span><span class="p">{</span>
				<span class="n">t</span><span class="o">=</span><span class="n">getmid</span><span class="p">();</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1064">1064</h1>
<h1 id="1068-find-more-conis01背包">1068 Find More Conis[01背包]</h1>
<p>有N枚硬币，给出每枚硬币的价值，现在要用这些硬币去支付价值为M的东西，问是否可以找到这样的方案，是的选择用来支付的硬币的价值正好是M。多种方式时选择字典序小的。</p>

<p>先将硬币按照价值 <em>逆序</em> 排序，然后用01背包的思路即可。需要注意的是，因为要输出选择的路径，所以要记录下每次状态转移选取的策略。</p>

<p>01背包中用dp[i][v]表示容量是v的背包中在前i件物品中选择的最大的价值。将背包的价值和重量等同，那么，dp[N][M]==M表示有解，否则无解。状态转移方程是<code class="highlighter-rouge">dp[i][v]=max{dp[i-1][v],dp[i][v-w[i]]+c[i]}</code>。开一个二维数组,choice[i][v]=0表示不选择i物品，choice[i][v]=1表示选择i物品，即分别对应状态转移方程的两种情况。相等时，说明可以选择更小的元素，即选当前元素。当然，这个选择的前提是硬币的价值逆序排列。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAXN 10004
#define MAXM 102
</span><span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="n">MAXM</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">choice</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="n">MAXM</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">MAXN</span><span class="p">),</span><span class="n">ans</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//freopen("d:\\input.txt","r",stdin);
</span>	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="n">M</span><span class="p">;</span>

	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
				<span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
				<span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span><span class="k">else</span><span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>
					<span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
					<span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span><span class="k">else</span><span class="p">{</span>
					<span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
					<span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">]</span><span class="o">!=</span><span class="n">M</span><span class="p">)</span><span class="n">printf</span><span class="p">(</span><span class="s">"No Solution</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">else</span><span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">N</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">M</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>
				<span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span><span class="k">else</span><span class="p">{</span>
				<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="n">printf</span><span class="p">(</span><span class="s">" %d"</span><span class="p">,</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1072-gas-station最短路径">1072 Gas Station[最短路径]</h1>
<p>有N所居民房、M个加油站待建点以及K条无向边。现在要从M个加油站待建点中选择一个来建造加油站，使得该加油站距离最近的居民房尽可能远，且必须保证所有的房子与该加油站的距离不超过给定的服务范围DS。现在给出N\M\K\DS，以及K条无向边的端点及边权，输出应当选择的加油站编号、与该加油站最近的居民房的距离、该加油站距离所有居民房的平均距离。如果有多个最近距离相等的解，那么选择平均距离最小的，如果平均距离也相同，则选择编号最小的。</p>

<p>对于每一个加油站，用Dijkstra求其与各个居民房的最短路径，然后根据题目条件判断取答案。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cc</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">)</span><span class="o">:</span><span class="n">c</span><span class="p">(</span><span class="n">cc</span><span class="p">),</span><span class="n">len</span><span class="p">(</span><span class="n">l</span><span class="p">){}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">char2int</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">lo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">st</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="sc">'G'</span><span class="p">){</span><span class="n">lo</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">st</span><span class="o">=</span><span class="n">n</span><span class="p">;}</span>
	<span class="k">while</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">){</span>
		<span class="n">id</span><span class="o">=</span><span class="n">id</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">c</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span><span class="o">-</span><span class="sc">'0'</span><span class="p">;</span>
		<span class="n">lo</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">id</span><span class="o">+</span><span class="n">st</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//freopen("D:\\input.txt","r",stdin);
</span>    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">D</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span><span class="o">&amp;</span><span class="n">D</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">s1</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">s2</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>
	<span class="c1">//这里的格式转换错了，因为k的取值范围是1-1000，应写成函数递归处理得到其值
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%s %s %d"</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
		<span class="n">c1</span><span class="o">=</span><span class="n">char2int</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
		<span class="n">c2</span><span class="o">=</span><span class="n">char2int</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
		<span class="n">grid</span><span class="p">[</span><span class="n">c1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span><span class="n">t</span><span class="p">));</span>
		<span class="n">grid</span><span class="p">[</span><span class="n">c2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="c1">//单元最短路径：迪杰斯特拉算法
</span>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">);</span>
	<span class="c1">//vector&lt;int&gt; path(n+m+1,-1);
</span>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mindist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">solution</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//记录可行方案数
</span>	<span class="kt">int</span> <span class="n">length</span><span class="o">=</span><span class="n">inf</span><span class="p">,</span><span class="n">minid</span><span class="p">,</span><span class="n">lengthsub</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">minsum</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span><span class="c1">//所有方案中最短路径及其序号,及离加气站最近的距离
</span>	<span class="kt">int</span> <span class="n">mxlen</span><span class="p">,</span><span class="n">minlen</span><span class="p">,</span><span class="n">sumlen</span><span class="p">;</span><span class="c1">//一个方案中的最长路径和最短路径、路径和
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//依次查询m个加油站到各个城市的最短路径是否符合题意，
</span>		<span class="n">fill</span><span class="p">(</span><span class="n">vis</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vis</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="nb">false</span><span class="p">);</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">dist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">dist</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">inf</span><span class="p">);</span>
		<span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
			<span class="kt">int</span> <span class="n">id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">mind</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span><span class="c1">//最小节点
</span>			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
				<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">!=</span><span class="n">inf</span><span class="p">){</span>
					<span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&lt;</span><span class="n">mind</span><span class="p">){</span><span class="n">mind</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="n">id</span><span class="o">=</span><span class="n">k</span><span class="p">;}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">==-</span><span class="mi">1</span><span class="p">){</span><span class="k">goto</span> <span class="n">loop</span><span class="p">;}</span>
			<span class="n">vis</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
				<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">c</span><span class="p">,</span><span class="n">len</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">dist</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">&gt;</span><span class="n">dist</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">){</span>
					<span class="n">dist</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mxlen</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">minlen</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span><span class="n">sumlen</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
			<span class="n">sumlen</span><span class="o">+=</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">mxlen</span><span class="p">)</span><span class="n">mxlen</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">minlen</span><span class="p">)</span><span class="n">minlen</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">mxlen</span><span class="o">&lt;=</span><span class="n">D</span><span class="p">){</span>
			<span class="n">solution</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">lengthsub</span><span class="o">&lt;</span><span class="n">minlen</span><span class="p">){</span><span class="n">length</span><span class="o">=</span><span class="n">mxlen</span><span class="p">;</span><span class="n">minid</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">lengthsub</span><span class="o">=</span><span class="n">minlen</span><span class="p">;</span><span class="n">mindist</span><span class="o">=</span><span class="n">dist</span><span class="p">;</span><span class="n">minsum</span><span class="o">=</span><span class="n">sumlen</span><span class="p">;}</span>
			<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">lengthsub</span><span class="o">==</span><span class="n">minlen</span><span class="o">&amp;&amp;</span><span class="n">minsum</span><span class="o">&gt;</span><span class="n">sumlen</span><span class="p">){</span><span class="n">minid</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">lengthsub</span><span class="o">=</span><span class="n">minlen</span><span class="p">;</span><span class="n">mindist</span><span class="o">=</span><span class="n">dist</span><span class="p">;</span><span class="n">minsum</span><span class="o">=</span><span class="n">sumlen</span><span class="p">;}</span>
		<span class="p">}</span>
		<span class="n">loop</span><span class="o">:</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">solution</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="n">printf</span><span class="p">(</span><span class="s">"No Solution"</span><span class="p">);</span>
	<span class="k">else</span><span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"G%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">minid</span><span class="o">-</span><span class="n">n</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d.0 %.1f"</span><span class="p">,</span><span class="n">lengthsub</span><span class="p">,(</span><span class="kt">float</span><span class="p">)</span><span class="n">minsum</span><span class="o">/</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1076-forward-on-weibobfs图遍历">1076 ForWard on Weibo[BFS图遍历]</h1>
<p>在微博中，每个用户都可能被其他用户关注。而当该用户发布一条信息时，他的关注者就可以看到这条信息并且选择是否转发它，且转发的信息也可以被转发者再次转发，但同一用户最多只转发该信息一次（信息的发布者不能转发该信息）。现在给出N个用户的关注情况以及一个转发层数上限L，并给出最初发布消息的用户编号，求在转发层上限内消息最多会被多少用户转发。</p>

<p>有转发层数限制，用BFS模板即可。注意到，当需要统计层次时，用广度优先搜索最佳，在每层末尾加标志元素以判断层数。也可以给每个节点增加层数变量，用一个数组即可实现，BFS的过程中设置层数，如果层数超限，就结束BFS</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//freopen("D:\\input.txt","r",stdin);
</span>    <span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">L</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">N</span><span class="p">,</span><span class="o">&amp;</span><span class="n">L</span><span class="p">);</span>
     <span class="c1">//定义邻接表
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">finded</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">m</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">K</span><span class="p">;</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">K</span><span class="p">);</span><span class="c1">//共K次查询
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="n">finded</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span><span class="c1">//BFS队列
</span>        <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//记录答案
</span>        <span class="kt">int</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span><span class="n">finded</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">//以0作为各层之间的标志位
</span>        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">level</span><span class="o">==</span><span class="n">L</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
                    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">finded</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">k</span><span class="p">]]){</span>
                        <span class="n">finded</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
                        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">k</span><span class="p">]);</span>
                        <span class="n">sum</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">sum</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1080">1080</h1>
<h1 id="1087-all-roads-lead-to-rome最短路径">1087 All Roads Lead To Rome[最短路径]</h1>
<p>有N个城市，M条无向边。现在需要从某个给定的城市出发（除了起始城市外，其他每个城市都有一个幸福值），前往名为ROM的城市。给出每条边所需要的花费，求从起始城市出发，到达城市ROM所需要的最少花费，并输出最少花费的路径。如果这样的路径有多条，则选择路径上城市的幸福值之和最大的那条。如果路径仍然不唯一，则选择路径上城市的平均幸福值最大的那条。</p>

<p>最短路径+第二点权+第三路径上节点个数</p>

<p>方法一：标志数组</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">M</span><span class="p">;</span><span class="c1">//记录最短路径的条数
</span><span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="n">len</span><span class="p">;</span>
	<span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">)</span><span class="o">:</span><span class="n">id</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">len</span><span class="p">(</span><span class="n">l</span><span class="p">){}</span>
<span class="p">};</span>

<span class="c1">//下面对ID的处理很常用
</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ID</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">name</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">getID</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ID</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">str</span><span class="p">))</span><span class="k">return</span> <span class="n">ID</span><span class="p">[</span><span class="n">str</span><span class="p">];</span>
	<span class="n">name</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ID</span><span class="p">[</span><span class="n">str</span><span class="p">]</span><span class="o">=</span><span class="n">name</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span><span class="n">INF</span><span class="p">),</span><span class="n">weight</span><span class="p">(</span><span class="n">MAXN</span><span class="p">),</span><span class="n">w1</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">w2</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span><span class="n">INF</span><span class="p">),</span><span class="n">path</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">num</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//第一权值是获得的快感更多，第二权值是经过的城市更少
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">MAXN</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">Dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">){</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">minid</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">mindist</span><span class="o">=</span><span class="n">INF</span><span class="p">;</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">mindist</span><span class="p">){</span>
				<span class="n">minid</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">mindist</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">minid</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
		<span class="n">vis</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">grid</span><span class="p">[</span><span class="n">minid</span><span class="p">].</span><span class="n">size</span><span class="p">()){</span>
			<span class="kt">int</span> <span class="n">next</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">minid</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">,</span><span class="n">len</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">minid</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">next</span><span class="p">])</span><span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">&gt;</span><span class="n">dist</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">){</span>
				<span class="n">num</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">num</span><span class="p">[</span><span class="n">minid</span><span class="p">];</span>
				<span class="n">dist</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">;</span>
				<span class="n">w1</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">w1</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
				<span class="n">w2</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">w2</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">path</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">minid</span><span class="p">;</span>
			<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">==</span><span class="n">dist</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">){</span>
				<span class="n">num</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">+=</span><span class="n">num</span><span class="p">[</span><span class="n">minid</span><span class="p">];</span>
				<span class="k">if</span><span class="p">(</span><span class="n">w1</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">&lt;</span><span class="n">w1</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">]){</span>
					<span class="n">w1</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">w1</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
					<span class="n">w2</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">w2</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
					<span class="n">path</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">minid</span><span class="p">;</span>
				<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">w1</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">==</span><span class="n">w1</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">weight</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">w2</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">&gt;</span><span class="n">w2</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
					<span class="n">w2</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">w2</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
					<span class="n">path</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">minid</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("d:\\input.txt","r",stdin);
</span>	<span class="n">string</span> <span class="n">str1</span><span class="p">,</span><span class="n">str2</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="n">K</span><span class="o">&gt;&gt;</span><span class="n">str1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="n">getID</span><span class="p">(</span><span class="n">str1</span><span class="p">),</span><span class="n">t</span><span class="p">;</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">){</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">str1</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">;</span>
		<span class="n">weight</span><span class="p">[</span><span class="n">getID</span><span class="p">(</span><span class="n">str1</span><span class="p">)]</span><span class="o">=</span><span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">K</span><span class="p">){</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">str1</span><span class="o">&gt;&gt;</span><span class="n">str2</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">c1</span><span class="o">=</span><span class="n">ID</span><span class="p">[</span><span class="n">str1</span><span class="p">],</span><span class="n">c2</span><span class="o">=</span><span class="n">ID</span><span class="p">[</span><span class="n">str2</span><span class="p">];</span>
		<span class="n">grid</span><span class="p">[</span><span class="n">c1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span><span class="n">t</span><span class="p">));</span>
		<span class="n">grid</span><span class="p">[</span><span class="n">c2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">w1</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">w2</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">num</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">Dijkstra</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">str1</span><span class="o">=</span><span class="s">"ROM"</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end</span><span class="o">=</span><span class="n">getID</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">num</span><span class="p">[</span><span class="n">end</span><span class="p">],</span><span class="n">dist</span><span class="p">[</span><span class="n">end</span><span class="p">],</span><span class="n">w1</span><span class="p">[</span><span class="n">end</span><span class="p">],</span><span class="n">w1</span><span class="p">[</span><span class="n">end</span><span class="p">]</span><span class="o">/</span><span class="n">w2</span><span class="p">[</span><span class="n">end</span><span class="p">]);</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">name</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
	<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">end</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">ans</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
		<span class="n">end</span><span class="o">=</span><span class="n">path</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">ans</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"-&gt;"</span><span class="o">&lt;&lt;</span><span class="n">name</span><span class="p">[</span><span class="n">ans</span><span class="p">.</span><span class="n">top</span><span class="p">()];</span>
		<span class="n">ans</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>方法二：DFS+Dijkstra如此复杂的判断条件，采用增加标志数组的方法容易出错。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ID</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">name</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">getID</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ID</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="k">return</span> <span class="n">ID</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
	<span class="n">name</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ID</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">name</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="n">len</span><span class="p">;</span>
	<span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">)</span><span class="o">:</span><span class="n">id</span><span class="p">(</span><span class="n">id</span><span class="p">),</span><span class="n">len</span><span class="p">(</span><span class="n">len</span><span class="p">){</span>	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">weight</span><span class="p">(</span><span class="n">MAXN</span><span class="p">);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">MAXN</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">path</span><span class="p">(</span><span class="n">MAXN</span><span class="p">);</span><span class="c1">//该节点的后续节点
</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span><span class="n">inf</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">,</span><span class="n">tmp</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">ansHappiness</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">Dijkstra</span><span class="p">(){</span>
	<span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">minid</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">t</span><span class="p">){</span>
				<span class="n">minid</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">t</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">minid</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
		<span class="n">vis</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>		
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">grid</span><span class="p">[</span><span class="n">minid</span><span class="p">].</span><span class="n">size</span><span class="p">()){</span>
			<span class="kt">int</span> <span class="n">next</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">minid</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">,</span><span class="n">len</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">minid</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">next</span><span class="p">]){</span>
				<span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">&gt;</span><span class="n">dist</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">){</span>
					<span class="n">dist</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">;</span>
					<span class="n">path</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
					<span class="n">path</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">minid</span><span class="p">);</span>
				<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">==</span><span class="n">dist</span><span class="p">[</span><span class="n">minid</span><span class="p">]</span><span class="o">+</span><span class="n">len</span><span class="p">){</span>
					<span class="n">path</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">minid</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">end</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">end</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">tmpHappiness</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">tmp</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="n">tmpHappiness</span><span class="o">+=</span><span class="n">weight</span><span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">tmpHappiness</span><span class="o">&gt;</span><span class="n">ansHappiness</span><span class="p">){</span>
			<span class="n">ans</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span><span class="n">ansHappiness</span><span class="o">=</span><span class="n">tmpHappiness</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">tmpHappiness</span><span class="o">==</span><span class="n">ansHappiness</span><span class="o">&amp;&amp;</span><span class="n">tmp</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
			<span class="n">ans</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">path</span><span class="p">[</span><span class="n">end</span><span class="p">].</span><span class="n">size</span><span class="p">()){</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">end</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">DFS</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">end</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
<span class="c1">//	freopen("d:\\input.txt","r",stdin);
</span>
	<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="n">M</span><span class="o">&gt;&gt;</span><span class="n">s</span><span class="p">;</span>
	<span class="n">getID</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="c1">//出发点的ID为0
</span>	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">){</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">s</span><span class="o">&gt;&gt;</span><span class="n">w</span><span class="p">;</span>
		<span class="n">weight</span><span class="p">[</span><span class="n">getID</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>
	<span class="p">}</span> 	
	<span class="n">string</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">M</span><span class="p">){</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">s1</span><span class="o">&gt;&gt;</span><span class="n">s2</span><span class="o">&gt;&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">c1</span><span class="o">=</span><span class="n">getID</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span><span class="n">c2</span><span class="o">=</span><span class="n">getID</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
		<span class="n">grid</span><span class="p">[</span><span class="n">c1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span><span class="n">len</span><span class="p">));</span>
		<span class="n">grid</span><span class="p">[</span><span class="n">c2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">len</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="n">end</span><span class="o">=</span><span class="n">getID</span><span class="p">(</span><span class="s">"ROM"</span><span class="p">);</span>

	<span class="n">Dijkstra</span><span class="p">();</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
	<span class="n">DFS</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">cnt</span><span class="p">,</span><span class="n">dist</span><span class="p">[</span><span class="n">end</span><span class="p">],</span><span class="n">ansHappiness</span><span class="p">,</span><span class="n">ansHappiness</span><span class="o">/</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">name</span><span class="p">[</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">&lt;&lt;</span><span class="s">"-&gt;"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"ROM"</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="1091">1091</h1>
<h1 id="1095">1095</h1>
<h1 id="1099">1099</h1>
<h1 id="1103">1103</h1>
<h1 id="1107-social-clusters并查集">1107 Social Clusters[并查集]</h1>
<p>有N个人，每个人喜欢若干项活动，如果两个人有任意一个活动相同，那么就称他们处于同一个社交网络。求N个人总共形成了多少个社交网络。</p>

<h1 id="1111">1111</h1>
<h1 id="1115">1115</h1>
<h1 id="1119">1119</h1>
<h1 id="1123">1123</h1>
<h1 id="1127">1127</h1>
<h1 id="1131">1131</h1>
<h1 id="1135">1135</h1>
<h1 id="1139">1139</h1>
<h1 id="1143">1143</h1>
<h1 id="1147">1147</h1>
<h1 id="1151">1151</h1>
  
	</div>
	<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <!--
  <%- list_categories(item.categories, {
      show_count: false,
      class: 'article-category',
      style: 'none',
      separator: '►'
  }) %>
  -->
  
  <a class="article-category-link" href="/categories/#algorithm">algorithm</a>
  
</div>


  <div class="article-tags">
  <!--
  <% var tags = [];
    item.tags.forEach(function(tag){
      tags.push('<a href="' + config.root + tag.path + '">' + tag.name + '</a>');
    }); %>-->
  <span></span> <!--<%- tags.join('') %>-->
  
  
  <a href="/tags/#DSA">DSA</a>
  
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://localhost:4000/algorithm/2018/04/02/PATadvanced/" data-title="PAT甲级考试最后一题总结 | Dipper" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>
   
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/algorithm/2018/03/12/jingdianAlgorithm/" title="算法竞赛入门经典">
  <strong>上一篇：</strong><br/>
  <span>
  算法竞赛入门经典</span>
</a>
</div>


<div class="next">
<a href="/algorithm/2018/05/03/cppSTL/"  title="C++STL总结">
 <strong>下一篇：</strong><br/> 
 <span>C++STL总结
</span>
</a>
</div>

</nav>

	

</div>  

      
      
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside toc-content">
 
 <!--<%- toc(item.content) %>-->
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/#reading-notes" title="reading-notes">reading-notes<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/#tools" title="tools">tools<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/#algorithm" title="algorithm">algorithm<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/#life" title="life">life<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/#design-pattern" title="design-pattern">design-pattern<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/#python-openCV" title="python-openCV">python-openCV<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/#python" title="python">python<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/#java" title="java">java<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/#aliyun" title="aliyun">aliyun<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/#deepLearning" title="deepLearning">deepLearning<sup>5</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/#读书" title="读书">读书<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/#markdown" title="markdown">markdown<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#DSA" title="DSA">DSA<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/#效率" title="效率">效率<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/#design-pattern" title="design-pattern">design-pattern<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#openCV" title="openCV">openCV<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/#python" title="python">python<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/#LaTex" title="LaTex">LaTex<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#爬虫" title="爬虫">爬虫<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#java" title="java">java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#spring" title="spring">spring<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#数字图像处理" title="数字图像处理">数字图像处理<sup>2</sup></a></li>
			
		
		</ul>
</div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div id="tagcloud" class="tagcloudlist clearfix">
    </div>
  </div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            <a href="https://blog.csdn.net/qq_20633793" target="_blank" title="我的CSDN">我的CSDN</a>
          </li>
        
          <li>
            <a href="http://47.93.52.194" target="_blank" title="我的WordPress">我的WordPress</a>
          </li>
        
    </ul>
</div>

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="jiangxiaohe" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
</div>



</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I'm Dipper. <br/>
			This is my blog. Happy to meet you.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/jiangxiaohe" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:ni-ys13@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
	<!--
			<%  Array.prototype.S=String.fromCharCode(2);
			  Array.prototype.in_array=function(e){
    			var r=new RegExp(this.S+e+this.S);
    			return (r.test(this.S+this.join(this.S)+this.S));
				};
				var cc = new Array('by','by-nc','by-nc-nd','by-nc-sa','by-nd','by-sa','zero'); %>
		<% if (cc.in_array(theme.creative_commons) ) { %>
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/<%= theme.creative_commons %>/4.0" class="cc-opacity" target="_blank">
            <img src="<%- config.root %>img/cc-<%= theme.creative_commons %>.svg" alt="Creative Commons" />
          </a>
        </div>
    <% } %>
				-->

		<p class="copyright">
		Powered by <a href="http://jekyllrb.com" target="_blank" title="jekyll">jekyll</a> and Theme by <a href="https://github.com/simpleyyt/jekyll-jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="about" target="_blank" title="Dipper">Dipper</a>
		
		
		</p>
</div>
</footer>
    <script src="/assets/js/jquery-2.0.3.min.js"></script>
<script src="/assets/js/jquery.imagesloaded.min.js"></script>
<script src="/assets/js/gallery.js"></script>
<script src="/assets/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="/assets/js/toc.js"></script>

<script type="text/javascript">
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });

  
        getSize();
        if (myWidth >= 1024) {
          c.click();
          $('#toc.toc-aside').show();
        }
  

  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
      
    }
  });
});
</script>


<script src="/assets/js/tagcloud.js"></script>
<script>
$(document).ready(function() {
  var tags = [
    
    { "name": "读书", "path": "/tags/#读书", "length": 5 },
    
    { "name": "markdown", "path": "/tags/#markdown", "length": 1 },
    
    { "name": "DSA", "path": "/tags/#DSA", "length": 10 },
    
    { "name": "效率", "path": "/tags/#效率", "length": 6 },
    
    { "name": "design-pattern", "path": "/tags/#design-pattern", "length": 2 },
    
    { "name": "openCV", "path": "/tags/#openCV", "length": 8 },
    
    { "name": "python", "path": "/tags/#python", "length": 7 },
    
    { "name": "LaTex", "path": "/tags/#LaTex", "length": 1 },
    
    { "name": "爬虫", "path": "/tags/#爬虫", "length": 3 },
    
    { "name": "java", "path": "/tags/#java", "length": 1 },
    
    { "name": "spring", "path": "/tags/#spring", "length": 1 },
    
    { "name": "数字图像处理", "path": "/tags/#数字图像处理", "length": 2 },
    
  ];
  $("#tagcloud").html(tagcloudHelper(tags));
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  $('#toc.toc-aside').toc({
    title: "文章目录",
    showEffect: "none"
  });
  $('#toc.toc-article').toc({
    title: "文章目录",
    showEffect: "show",
    showSpeed: 0
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
/*
  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      //$('.hoverqrcode').hide();
  });
  */
});
</script>






<!--

-->




<link rel="stylesheet" href="/assets/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/assets/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      if ($(this).hasClass('emoji')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>


<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/assets/img/scrollup.png"/></a>
	</div>
	<script src="/assets/js/totop.js"></script>


<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

