

 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
    
    
    
    
    <title>C++STL总结 | Dipper</title>


    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Dipper">
    

    
    <!--<%- open_graph({twitter_id: theme.author.twitter, google_plus: theme.author.google_plus}) %>-->

    <meta name="description" content="page.description">
    
    <meta property="og:type" content="article">
    
    <meta property="og:title" content="C++STL总结">
    <meta property="og:url" content="/algorithm/2018/05/03/cppSTL/">
    <meta property="og:site_name" content="Dipper">
    <meta property="og:description" content="在学堂在线DSA课程的基础上，实现C++的典型STL">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="C++STL总结">
    <meta name="twitter:description" content="page.description">
    <meta name="twitter:creator" content="@">
    <link rel="publisher" href="">

    
    
    <link rel="icon" href="/assets/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/assets/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/assets/img/jacman.jpg">
    

    <link rel="stylesheet" href="/assets/css/main.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/highlight.css" type="text/css">
    
    <style>
        body >header {
            background: url("/assets/img/banner.jpg") center #2ca6cb;
        }
    </style>
    
    
</head>

  <body>
    <header>
        <div>
		    
			<div id="imglogo">
				<a href="/"><img src="/assets/img/dipper_logo.jpg" alt="Dipper" title="Dipper"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Dipper">Dipper</a></h1>
				<h2 class="blog-motto">stay foolish, stay hungry</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/categories">目录</a></li>
					
						<li><a href="/about">关于我</a></li>
					
					<li>
 					
					<form class="search" action="/search" method="get" accept-charset="utf-8">
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>
</div>

    </header>
    <div id="container">
      



<div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
	<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/algorithm/2018/05/03/cppSTL/" title="C++STL总结" itemprop="url">C++STL总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dipper" target="_blank" itemprop="author">Dipper</a>
		
  <p class="article-time">
    <time datetime="2018-05-03 00:00:00 +0800" itemprop="datePublished"> 发表于 2018-05-03</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article toc-content" style="display: none;">
		
			<!--<%- toc(item.content) %>-->
		
		</div>
		
		<h1 id="vector">Vector</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef VECTOR_H
#define VECTOR_H
</span>
<span class="cp">#define CAPACITY 10
#define Rank int
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">_capacity</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">T</span><span class="o">*</span> <span class="n">_elem</span><span class="p">;</span>
	<span class="c1">//构造与析构
</span>	<span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">ncapacity</span> <span class="o">=</span> <span class="n">CAPACITY</span><span class="p">)</span> <span class="p">{</span> <span class="n">_capacity</span> <span class="o">=</span> <span class="n">ncapacity</span><span class="p">;</span> <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">_elem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_capacity</span><span class="p">];</span> <span class="p">}</span><span class="c1">//注意这里是[]，而不是小括号
</span>
	<span class="kt">void</span> <span class="n">copyFrom</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_elem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">];</span> <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">)</span><span class="n">_elem</span><span class="p">[</span><span class="n">_size</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">lo</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">Vector</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span> <span class="n">copyFrom</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span> <span class="p">}</span>

	<span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="c1">//整体复制
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">)</span><span class="k">delete</span><span class="p">[]</span> <span class="n">_elem</span><span class="p">;</span>
		<span class="n">copyFrom</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">_elem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">Vector</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span>  <span class="n">_elem</span><span class="p">;</span> <span class="p">}</span>

	<span class="kt">void</span> <span class="n">expand</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_size</span> <span class="o">==</span> <span class="n">_capacity</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">T</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">;</span> <span class="n">_capacity</span> <span class="o">=</span> <span class="n">_capacity</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">_elem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_capacity</span><span class="p">];</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">delete</span><span class="p">[]</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">shrink</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_size</span> <span class="o">&gt;=</span> <span class="n">_capacity</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span><span class="k">return</span><span class="p">;</span><span class="c1">//以25%为界
</span>		<span class="n">T</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">;</span> <span class="n">_elem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_capacity</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">delete</span><span class="p">[]</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

	<span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

	<span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">Rank</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>

	<span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">expand</span><span class="p">();</span> <span class="n">_elem</span><span class="p">[</span><span class="n">_size</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>

	<span class="n">T</span> <span class="n">pop_back</span><span class="p">()</span> <span class="p">{</span> <span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="o">--</span><span class="n">_size</span><span class="p">];</span> <span class="n">shrink</span><span class="p">();</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>

	<span class="c1">//遍历，使用函数对象
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">VST</span><span class="o">&gt;</span>
	<span class="kt">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">VST</span><span class="o">&amp;</span> <span class="n">visit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">Rank</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">visit</span><span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">Rank</span> <span class="n">insert</span><span class="p">(</span><span class="n">Rank</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">expand</span><span class="p">();</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">_elem</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//删除[lo,hi)区间内的节点
</span>	<span class="kt">int</span> <span class="n">remove</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;</span> <span class="n">_size</span><span class="p">)</span><span class="n">_elem</span><span class="p">[</span><span class="n">lo</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="n">hi</span><span class="o">++</span><span class="p">];</span>
		<span class="n">_size</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
		<span class="n">shrink</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//删除单个节点
</span>	<span class="n">T</span> <span class="n">remove</span><span class="p">(</span><span class="n">Rank</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="n">T</span> <span class="n">e</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="n">r</span><span class="p">];</span> <span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="k">return</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span>

	<span class="c1">//无序向量中找最大值
</span>	<span class="n">Rank</span> <span class="n">findmax</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Rank</span> <span class="n">max</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">Rank</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_elem</span><span class="p">[</span><span class="n">max</span><span class="p">])</span><span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//无序向量的顺序查找，找到返回秩，找不到返回-1
</span>	<span class="n">Rank</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Rank</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span><span class="k">break</span><span class="p">;</span><span class="c1">//假设hi位置是一个无穷大哨兵
</span>		<span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">hi</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">Rank</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span> <span class="p">}</span>

	<span class="c1">//search表示更高级的查找算法，如二分，find表示顺序查找
</span>	<span class="n">Rank</span> <span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span><span class="c1">//二分查找[lo,hi)
</span>		<span class="kt">int</span> <span class="n">mi</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">)</span><span class="n">lo</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mi</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">lo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Rank</span> <span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span> <span class="p">}</span>

	<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">_size</span><span class="o">&amp;&amp;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_size</span><span class="p">)</span><span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//排序算法
</span>	<span class="kt">void</span> <span class="n">bubbleSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">selectionSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">insertSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">merge</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">mi</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">);</span>
	<span class="c1">//void heapSort(Rank lo, Rank hi);
</span>	<span class="kt">void</span> <span class="n">quickSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">);</span>

	<span class="c1">//重载默认排序算法，不能用bubbleSort(Rank lo=0,Rank hi=_size)
</span>	<span class="c1">//因为类中非静态成员变量不能作为默认参数，应采用这种重载的方式
</span>	<span class="kt">void</span> <span class="n">bubbleSort</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">selectionSort</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">insertSort</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">mergeSort</span><span class="p">();</span>
	<span class="c1">//void heapSort();
</span>	<span class="kt">void</span> <span class="n">quickSort</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">bubbleSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">bool</span> <span class="n">sorted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">hi</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sorted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">hi</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">Rank</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_elem</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="n">sorted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="n">swap</span><span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_elem</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">last</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">bubbleSort</span><span class="p">()</span> <span class="p">{</span> <span class="n">bubbleSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">selectionSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Rank</span> <span class="n">max</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">findmax</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)],</span> <span class="n">_elem</span><span class="p">[</span><span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">hi</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">selectionSort</span><span class="p">()</span> <span class="p">{</span> <span class="n">selectionSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insertSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">Rank</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">Rank</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="o">--</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span><span class="n">_elem</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">_elem</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insertSort</span><span class="p">()</span> <span class="p">{</span> <span class="n">insertSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">merge</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">mi</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span><span class="c1">//原序列、左部分、有部分分别用abc表示
</span>	<span class="kt">int</span> <span class="n">lb</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">,</span> <span class="n">lc</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">mi</span><span class="p">;</span>
	<span class="n">T</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">lb</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="n">lo</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
	<span class="n">Rank</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">mi</span><span class="p">;</span>
	<span class="cm">/*改进前判断的条件有三个
	while(i&lt;hi){//注意这里添加尾部无穷大哨兵的做法
		while(j&lt;lb&amp;&amp;(k==hi||tmp[j]&lt;=_elem[k]))_elem[i++]=tmp[j++];
		while(k&lt;hi&amp;&amp;(j==lb||tmp[j]&gt;_elem[k]))_elem[i++]=_elem[k++];
	}*/</span>
	<span class="cm">/*改进后，注意内部两个while的顺序，j++的执行应放在最后。而且，第二句不能用while，应为内部while的入口没有判断j是否越界。
	while(j&lt;lb){
		while(k&lt;hi&amp;&amp;tmp[j]&gt;_elem[k])_elem[i++]=_elem[k++];
		if(k&gt;=hi||tmp[j]&lt;=_elem[k])_elem[i++]=tmp[j++];

	}*/</span>
	<span class="c1">//上述版本虽然简洁，但是不易维护。如下代码虽然增加了一行，但是易维护、易理解
</span>	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">lb</span><span class="o">&amp;&amp;</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">lb</span><span class="o">&amp;&amp;</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">_elem</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">k</span><span class="o">&lt;</span><span class="n">hi</span><span class="o">&amp;&amp;</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">_elem</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">lb</span><span class="p">)</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	<span class="k">delete</span><span class="p">[]</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">mergeSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="k">return</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mergeSort</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
	<span class="n">mergeSort</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">mi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_elem</span><span class="p">[</span><span class="n">mi</span><span class="p">])</span><span class="n">merge</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span><span class="c1">//加入这一句判断，减少不必要的merge操作
</span><span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">mergeSort</span><span class="p">()</span> <span class="p">{</span> <span class="n">mergeSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">//快排
</span><span class="cm">/*就地重拍算法可以有三种
	方法一：阿哈算法，中间元素先完成全部交换，最后再与首元素交换，注意把左侧元素当做标记元素的时候，先从右向左找:初始化i=lo+1,j=hi,首先j向左找比标记位小的元素，i向右找比标记位大的元素，然后将两者交换，不断重复这个过程，直到两者相等，i=j时可以判断，[lo+1,i]均比标记小，(i,hi]均比标记大，最后，再交换下lo,i即可。
	方法二：邓老师书中采用的是两边比较，不断变换空闲位置，把最左侧元素放到接近的位置，最后把第一个元素的复制放在最后一个空闲位置。
	方法三：《算法导论》
*/</span>

<span class="c1">//方法一：阿哈算法，中间交换，最后把lo换到中间
</span><span class="kt">int</span> <span class="n">partition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span><span class="kt">int</span> <span class="n">lo</span><span class="p">,</span><span class="kt">int</span> <span class="n">hi</span><span class="p">){</span><span class="c1">//[lo,hi]上层调用函数保证了lo&lt;hi
</span>	<span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">],</span><span class="n">vec</span><span class="p">[</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">lo</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">lo</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">hi</span><span class="p">;</span><span class="c1">//注意这里一定从lo出发，这样可以保证lo是最小元素的情况
</span>	<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="p">){</span>
		<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="o">&amp;&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">])</span><span class="n">j</span><span class="o">--</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="o">&amp;&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">])</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">],</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="c1">//这里交换一定要发生才能把lo元素放到中间来
</span>	<span class="c1">//cout&lt;&lt;"lo="&lt;&lt;lo&lt;&lt;"  hi="&lt;&lt;hi&lt;&lt;"  i="&lt;&lt;i&lt;&lt;endl;printvec(vec);
</span>	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//方法二：邓老师版本，两边不停的向中间扫描
</span>
<span class="c1">//版本A，勤于拓展，懒于交换
</span><span class="kt">int</span> <span class="n">partitionA</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span><span class="kt">int</span> <span class="n">lo</span><span class="p">,</span><span class="kt">int</span> <span class="n">hi</span><span class="p">){</span><span class="c1">//语义规定：对[lo,hi]两头闭区间进行就地重拍
</span>    <span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">],</span><span class="n">vec</span><span class="p">[</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">lo</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">hi</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">hi</span><span class="o">&amp;&amp;</span><span class="n">tmp</span><span class="o">&lt;=</span><span class="n">vec</span><span class="p">[</span><span class="n">hi</span><span class="p">])</span><span class="n">hi</span><span class="o">--</span><span class="p">;</span><span class="c1">//向左扩展右端子序列
</span>        <span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">hi</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">hi</span><span class="o">&amp;&amp;</span><span class="n">tmp</span><span class="o">&gt;=</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">])</span><span class="n">lo</span><span class="o">++</span><span class="p">;</span><span class="c1">//向右扩展
</span>        <span class="n">vec</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">];</span>
    <span class="p">}</span>
	<span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lo</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//版本B：勤于交换，懒于拓展
</span><span class="kt">int</span> <span class="n">partitionB</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span><span class="kt">int</span> <span class="n">lo</span><span class="p">,</span><span class="kt">int</span> <span class="n">hi</span><span class="p">){</span><span class="c1">//语义规定：对[lo,hi]两头闭区间进行就地重拍
</span>    <span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">],</span><span class="n">vec</span><span class="p">[</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">lo</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">hi</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">hi</span><span class="o">&amp;&amp;</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">vec</span><span class="p">[</span><span class="n">hi</span><span class="p">])</span><span class="n">hi</span><span class="o">--</span><span class="p">;</span><span class="c1">//向左扩展右端子序列
</span>        <span class="k">if</span><span class="p">(</span><span class="n">lo</span><span class="o">==</span><span class="n">hi</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
		<span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">hi</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">hi</span><span class="o">&amp;&amp;</span><span class="n">tmp</span><span class="o">&gt;</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">])</span><span class="n">lo</span><span class="o">++</span><span class="p">;</span><span class="c1">//向右扩展
</span>		<span class="k">if</span><span class="p">(</span><span class="n">lo</span><span class="o">==</span><span class="n">hi</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
        <span class="n">vec</span><span class="p">[</span><span class="n">hi</span><span class="o">--</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">];</span>
    <span class="p">}</span>
	<span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lo</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*方法三：算法导论版本，将最后一个元素放入其应该的位置,[lo,hi]是待排序序列，(i,j)表示比vec[lo]大的元素的集合，从左向右扩展，初始化i=lo-1，j=lo，表示没有元素，然后j向右探索
    遇到的元素比hi元素小，如果i,j中间没有元素，就i++,j++,表示跳过该元素，如果i，j之间有元素，就交换(i+1,j),然后i++,j++
    当j遇到hi时,退出循环，交换(i+1,j)即可
    找到比lo小的元素就交换(i,j-1)，然后j--，就继续满足[i,j)比vec[lo]小。当i=lo时退出循环，交换(i,j-1)，返回j-1
*/</span>
<span class="kt">int</span> <span class="n">partition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span><span class="kt">int</span> <span class="n">lo</span><span class="p">,</span><span class="kt">int</span> <span class="n">hi</span><span class="p">){</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">lo</span><span class="p">],</span><span class="n">vec</span><span class="p">[</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">lo</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">lo</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">lo</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">hi</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">hi</span><span class="o">&amp;&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">vec</span><span class="p">[</span><span class="n">hi</span><span class="p">])</span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">hi</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">j</span><span class="p">)</span><span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">vec</span><span class="p">[</span><span class="n">hi</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">quickSort</span><span class="p">(</span><span class="n">Rank</span> <span class="n">lo</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">hi</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">lo</span><span class="o">&gt;=</span><span class="n">hi</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="k">return</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mi</span><span class="o">=</span><span class="n">partition</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">quicksort</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">mi</span><span class="p">);</span>
	<span class="n">quicksort</span><span class="p">(</span><span class="n">mi</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">hi</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">quickSort</span><span class="p">()</span> <span class="p">{</span> <span class="n">quickSort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span> <span class="p">}</span>

<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="list">List</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef LIST_H
#define LIST_H
</span>
<span class="cp">#define Rank int
#define NULL 0
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ListNode</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pred</span><span class="p">;</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">succ</span><span class="p">;</span>
	<span class="n">T</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">ListNode</span><span class="p">()</span> <span class="p">{};</span>
	<span class="n">ListNode</span><span class="p">(</span><span class="n">T</span> <span class="n">e</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">pred</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">succ</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>

	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsPred</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">succ</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">succ</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsSucc</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pred</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">succ</span> <span class="o">=</span> <span class="n">succ</span><span class="p">;</span> <span class="n">succ</span><span class="o">-&gt;</span><span class="n">pred</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">succ</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">tailer</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">front</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">succ</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">back</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">tailer</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">;</span> <span class="p">}</span>

	<span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">header</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
		<span class="n">tailer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
		<span class="n">header</span><span class="o">-&gt;</span><span class="n">succ</span> <span class="o">=</span> <span class="n">tailer</span><span class="p">;</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">pred</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tailer</span><span class="o">-&gt;</span><span class="n">pred</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span> <span class="n">tailer</span><span class="o">-&gt;</span><span class="n">succ</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">copyNode</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="n">insertAsLast</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">succ</span><span class="p">;</span> <span class="p">}</span>
	<span class="p">}</span>

	<span class="n">List</span><span class="p">()</span> <span class="p">{</span> <span class="n">init</span><span class="p">();</span> <span class="p">}</span>

	<span class="n">List</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">copyNode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="p">}</span>

	<span class="n">List</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">L</span><span class="p">)</span> <span class="p">{</span> <span class="n">copyNode</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">first</span><span class="p">(),</span> <span class="n">L</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">}</span>

	<span class="c1">//复制L中自r起的n项
</span>	<span class="n">List</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">copyNode</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span> <span class="p">}</span>

	<span class="c1">//清空所有节点
</span>	<span class="o">~</span><span class="n">List</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">header</span><span class="p">;</span> <span class="k">delete</span> <span class="n">tailer</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">int</span> <span class="n">clear</span><span class="p">()</span> <span class="p">{}</span>

	<span class="c1">//插入操作
</span>	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertBefore</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">,</span> <span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">insertAsPred</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAfter</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">,</span> <span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">insertAsSucc</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsFirst</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">insertAsSucc</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsLast</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">tailer</span><span class="o">-&gt;</span><span class="n">insertAsPred</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">insertAsLast</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>

	<span class="c1">//删除，假定T类型可以直接复制，返回其值
</span>	<span class="n">T</span> <span class="n">remove</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span> <span class="n">_size</span><span class="o">--</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">pred</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">succ</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">succ</span><span class="p">;</span>
		<span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">T</span> <span class="n">removeAtFirst</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">succ</span><span class="p">);</span> <span class="p">};</span>

	<span class="c1">//寻秩访问，效率很低,注意这里返回值为引用
</span>	<span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">Rank</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">succ</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//遍历
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">VST</span><span class="o">&gt;</span>
	<span class="kt">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">VST</span><span class="o">&amp;</span> <span class="n">visit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">succ</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">tailer</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">succ</span><span class="p">)</span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//查找，与向量一样，无论成功与否，都要便于后续插入等操作的实现
</span>	<span class="c1">//在p的n个真前驱中，查找元素e
</span>	<span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">search</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">--</span><span class="p">)</span><span class="c1">//这里的循环是n+1次，最后n=0的时候，比较毫无意义，只是为了定位到要返回的节点，即p的n+1个真前驱
</span>			<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//排序
</span>	<span class="kt">void</span> <span class="n">merge</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">selectionSort</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">insertSort</span><span class="p">(</span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="stack">Stack</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef STACK_H
#define STACK_H
</span>
<span class="cp">#include"Vector.h"
#include&lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Stack</span> <span class="o">:</span><span class="k">public</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="c1">//注意派生类的构造函数写法，成员对象名的个数与顺序
</span>	<span class="n">Stack</span><span class="p">(</span><span class="kt">int</span> <span class="n">_capacity</span> <span class="o">=</span> <span class="n">CAPACITY</span><span class="p">)</span> <span class="o">:</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_capacity</span><span class="p">)</span> <span class="p">{}</span>
	<span class="c1">//~Stack(){}
</span>	<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">T</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span>
	<span class="n">T</span> <span class="n">top</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//进制转换，这里用栈实现数值转化的算法是非常简单的
</span><span class="kt">void</span> <span class="nf">convert</span><span class="p">(</span><span class="n">Stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">digit</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'0'</span><span class="p">,</span><span class="sc">'1'</span><span class="p">,</span><span class="sc">'2'</span><span class="p">,</span><span class="sc">'3'</span><span class="p">,</span><span class="sc">'4'</span><span class="p">,</span><span class="sc">'5'</span><span class="p">,</span><span class="sc">'6'</span><span class="p">,</span><span class="sc">'7'</span><span class="p">,</span><span class="sc">'8'</span><span class="p">,</span><span class="sc">'9'</span><span class="p">,</span><span class="sc">'A'</span><span class="p">,</span><span class="sc">'B'</span><span class="p">,</span><span class="sc">'C'</span><span class="p">,</span><span class="sc">'D'</span><span class="p">,</span><span class="sc">'E'</span><span class="p">,</span><span class="sc">'F'</span> <span class="p">};</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">digit</span><span class="p">[(</span><span class="kt">int</span><span class="p">)(</span><span class="n">n</span><span class="o">%</span><span class="n">base</span><span class="p">)]);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">base</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//重要：判断一个排列(0-n)是不是栈混洗
</span><span class="kt">bool</span> <span class="nf">isStackMixing</span><span class="p">(</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span><span class="c1">//这里的参数应该是引用
</span>	<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//[0,n)的队列
</span>	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//vec参数的秩
</span>	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span><span class="c1">//循环，反复入栈出栈
</span>		<span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
			<span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//括号匹配，代码编译过程的重要一环，先写只有()的情况，再写加入了[]{}的情况
</span><span class="kt">bool</span> <span class="nf">paren</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">exp</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">'('</span><span class="p">:</span><span class="k">case</span> <span class="sc">'['</span><span class="p">:</span><span class="k">case</span> <span class="sc">'{'</span><span class="p">:</span><span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">')'</span><span class="p">:</span><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">']'</span><span class="p">:</span><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">'['</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'}'</span><span class="p">:</span><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">'{'</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span><span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//逆波兰表达式RPN计算
//先建立不同运算符的优先关系
</span><span class="cp">#define N_OPER 9
</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ADD</span><span class="p">,</span> <span class="n">SUB</span><span class="p">,</span> <span class="n">MUL</span><span class="p">,</span> <span class="n">DIV</span><span class="p">,</span> <span class="n">POW</span><span class="p">,</span> <span class="n">FAC</span><span class="p">,</span> <span class="n">L_P</span><span class="p">,</span> <span class="n">R_P</span><span class="p">,</span> <span class="n">EOE</span> <span class="p">}</span> <span class="n">Operator</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">pri</span><span class="p">[</span><span class="n">N_OPER</span><span class="p">][</span><span class="n">N_OPER</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="c1">//这里要搞清楚点，优先级关系如何定义，对括号如何处理
</span>				<span class="cm">/*         当前运算符                   */</span>
				<span class="cm">/*  +   -   *   /   ^   !   (   )   \0 */</span>
	<span class="cm">/*	    + */</span>   <span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span>
	<span class="cm">/*	    - */</span>   <span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span>
	<span class="cm">/*	之  * */</span>   <span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span>
	<span class="cm">/*	前  / */</span>   <span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span>
	<span class="cm">/*	运  ^ */</span>   <span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span>
	<span class="cm">/*	算  ! */</span>   <span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span><span class="sc">'&gt;'</span><span class="p">,</span>
	<span class="cm">/*	符  ( */</span>   <span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'='</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span>
	<span class="cm">/*	    ) */</span>   <span class="sc">' '</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span>
	<span class="cm">/*	    \0*/</span>   <span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">'&lt;'</span><span class="p">,</span><span class="sc">' '</span><span class="p">,</span><span class="sc">'='</span>
	<span class="c1">//注意，这一行对应头部哨兵的情况，简化控制流程边界情况的处理，最后这个等号，是建立头哨兵\0，以便处理结尾的情况
</span><span class="p">};</span>

<span class="c1">//读取从i开始的操作数,tRPN指RPN当前的指针
</span><span class="kt">int</span> <span class="nf">readnum</span><span class="p">(</span><span class="kt">char</span><span class="o">*&amp;</span> <span class="n">S</span><span class="p">,</span> <span class="kt">char</span><span class="o">*&amp;</span> <span class="n">tRPN</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">S</span> <span class="o">!=</span> <span class="sc">'\0'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">S</span> <span class="o">&gt;=</span> <span class="sc">'0'</span><span class="o">&amp;&amp;*</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">*</span><span class="n">S</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
		<span class="o">*</span><span class="p">(</span><span class="n">tRPN</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">S</span><span class="p">;</span>
		<span class="n">S</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="p">(</span><span class="n">tRPN</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//计算RPN表达式
</span><span class="kt">int</span> <span class="nf">readnum</span><span class="p">(</span><span class="kt">char</span><span class="o">*&amp;</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">S</span> <span class="o">!=</span> <span class="sc">'\0'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">S</span> <span class="o">&gt;=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="o">*</span><span class="n">S</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
		<span class="n">S</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//比较两个操作的优先级
</span><span class="kt">char</span> <span class="nf">orderbetween</span><span class="p">(</span><span class="kt">char</span> <span class="n">oper1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">oper2</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Operator</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">oper1</span><span class="p">,</span><span class="n">oper2</span> <span class="p">};</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span><span class="sc">'+'</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ADD</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span><span class="sc">'-'</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SUB</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span><span class="sc">'*'</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">MUL</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span><span class="sc">'/'</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">DIV</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span><span class="sc">'^'</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">POW</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span><span class="sc">'!'</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FAC</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span><span class="sc">'('</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_P</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span><span class="sc">')'</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R_P</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span><span class="sc">'\0'</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">EOE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pri</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
<span class="p">}</span>

<span class="c1">//实现表达式求值算法，对已剔除白空格的表达式S求值，并转换为RPN表达式
</span><span class="kt">float</span> <span class="nf">evaluate</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">S</span><span class="p">,</span> <span class="kt">char</span><span class="o">*&amp;</span> <span class="n">RPN</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">tRPN</span> <span class="o">=</span> <span class="n">RPN</span><span class="p">;</span><span class="c1">//tRPN表示RPN当前的指针,谨记，RPN的顺序使出栈计算的顺序而非入栈的顺序
</span>	<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numStack</span><span class="p">;</span>
	<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">operStack</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">opernum1</span><span class="p">,</span> <span class="n">opernum2</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">opertmp</span><span class="p">,</span> <span class="n">oper</span><span class="p">;</span>
	<span class="n">operStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">'\0'</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">operStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">S</span> <span class="o">&gt;=</span> <span class="sc">'0'</span><span class="o">&amp;&amp;*</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">opernum1</span> <span class="o">=</span> <span class="n">readnum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">tRPN</span><span class="p">);</span> <span class="n">numStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">opernum1</span><span class="p">);</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="c1">//注意这里对不同优先级的处理策略
</span>			<span class="c1">//尤其是栈顶优先级较高的情况，取操作数计算而不入栈
</span>			<span class="c1">//当前优先级较高时，入栈而接收下一个字符
</span>			<span class="n">opertmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">S</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">orderbetween</span><span class="p">(</span><span class="n">operStack</span><span class="p">.</span><span class="n">top</span><span class="p">(),</span> <span class="n">opertmp</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span><span class="sc">'&gt;'</span><span class="p">:</span><span class="c1">//栈顶元素优先级更高，需取出操作数计算，然后结果重新入栈，当前运算符不变
</span>				<span class="n">opernum1</span> <span class="o">=</span> <span class="n">numStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="n">oper</span> <span class="o">=</span> <span class="n">operStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
				<span class="o">*</span><span class="p">(</span><span class="n">tRPN</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">oper</span><span class="p">;</span><span class="c1">//*(tRPN++)=' ';此处不加空格，此处需要与RPN计算的算法相互配合
</span>				<span class="k">if</span> <span class="p">(</span><span class="n">oper</span> <span class="o">!=</span> <span class="sc">'!'</span><span class="p">)</span> <span class="p">{</span><span class="c1">//双目运算符取两个操作数
</span>					<span class="n">opernum2</span> <span class="o">=</span> <span class="n">numStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
					<span class="n">numStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">opernum1</span><span class="p">,</span> <span class="n">opernum2</span><span class="p">,</span> <span class="n">oper</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span><span class="c1">//单目运算符取一个操作符即可
</span>					<span class="n">numStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fac</span><span class="p">(</span><span class="n">opernum1</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span><span class="sc">'&lt;'</span><span class="p">:</span><span class="c1">//当前运算符优先级更高时，直接将当前运算符入栈，并接收下一个字符
</span>				<span class="n">operStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">opertmp</span><span class="p">);</span> <span class="n">S</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span><span class="sc">'='</span><span class="p">:</span><span class="c1">//两者优先级相等时，去除括号，并接收下一个字符
</span>				<span class="n">operStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="n">S</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//语法错误，暂不做处理
</span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">tRPN</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">numStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//计算RPN表达式的值
</span><span class="kt">float</span> <span class="nf">rpnEvaluation</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">numStack</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">opernum1</span><span class="p">,</span> <span class="n">opernum2</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">oper</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">S</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">S</span> <span class="o">&gt;=</span> <span class="sc">'0'</span><span class="o">&amp;&amp;*</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">numStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">readnum</span><span class="p">(</span><span class="n">S</span><span class="p">));</span>
			<span class="n">S</span><span class="o">++</span><span class="p">;</span><span class="c1">//跳过空格
</span>		<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">S</span> <span class="o">==</span> <span class="sc">'!'</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">opernum1</span> <span class="o">=</span> <span class="n">numStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">numStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fac</span><span class="p">(</span><span class="n">opernum1</span><span class="p">));</span>
			<span class="n">S</span><span class="o">++</span><span class="p">;</span>
			<span class="c1">//到下一个运算符，注意这里的操作是和RPN的生成相互配合的，RPN生成算法中，每个数字后面补充一个空格，故读取数字时要跳过空格，而运算符后没有空格，故不用跳过空格。
</span>		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="n">opernum1</span> <span class="o">=</span> <span class="n">numStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">opernum2</span> <span class="o">=</span> <span class="n">numStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">numStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">opernum1</span><span class="p">,</span> <span class="n">opernum2</span><span class="p">,</span> <span class="o">*</span><span class="n">S</span><span class="p">));</span>
			<span class="n">S</span><span class="o">++</span><span class="p">;</span><span class="c1">//到下一个运算符
</span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">numStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//试探回溯法解八皇后问题
</span><span class="k">struct</span> <span class="n">Queen</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">Queen</span><span class="p">(</span><span class="kt">int</span> <span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span><span class="n">x</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span> <span class="p">{}</span>
	<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Queen</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">||</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">||</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">placeQueens</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Stack</span><span class="o">&lt;</span><span class="n">Queen</span><span class="o">&gt;</span> <span class="n">solu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nsolu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ncheck</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Queen</span> <span class="n">q</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">solu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="c1">//不断的试探回溯,忒休斯的绳索是栈，入栈是进一步，出栈是退一步
</span>	<span class="k">while</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="n">q</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//这是书中的答案
</span>		<span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&lt;=</span><span class="n">solu</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">||</span><span class="n">N</span><span class="o">&lt;=</span><span class="n">q</span><span class="p">.</span><span class="n">y</span><span class="p">){</span><span class="c1">//若已经出界，则回溯一行
</span>			<span class="n">q</span><span class="o">=</span><span class="n">solu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="n">q</span><span class="p">.</span><span class="n">y</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">//没有出界时，试探下一行
</span>			<span class="k">while</span><span class="p">((</span><span class="n">q</span><span class="p">.</span><span class="n">y</span><span class="o">&lt;</span><span class="n">N</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">solu</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">))){</span>
				<span class="n">q</span><span class="p">.</span><span class="n">y</span><span class="o">++</span><span class="p">;</span><span class="n">ncheck</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">y</span><span class="p">){</span>
				<span class="n">solu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&lt;=</span><span class="n">solu</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="n">nsolu</span><span class="o">++</span><span class="p">;</span>
				<span class="n">q</span><span class="p">.</span><span class="n">x</span><span class="o">++</span><span class="p">;</span><span class="n">q</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//转入下一行
</span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*测试
	char a[]="(6+3)/(1+3!)";"(0!+1)*2^(3!+4)-(5!-67-(8+9))"
	char* RPN=new char[30];
	float ans=evaluate(a,RPN);
	float ans2=rpnEvaluation(RPN);
	cout&lt;&lt;a&lt;&lt;endl;
	cout&lt;&lt;ans&lt;&lt;endl;
	cout&lt;&lt;RPN&lt;&lt;endl;
	cout&lt;&lt;ans2&lt;&lt;endl;
*/</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="queue">Queue</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef QUEUE_H
#define QUEUE_H
</span>
<span class="cp">#include"List.h"
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Queue</span> <span class="o">:</span><span class="k">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">insertAsLast</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">T</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">removeAtFirst</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="bintreenode">BinTreeNode</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINTREENODE_H
#define BINTREENODE_H
</span>
<span class="c1">//快捷方式
</span><span class="cp">#define isRoot(x) (!(x)-&gt;parent)
#define isLChild(x) ((x)-&gt;parent&amp;&amp;(x)-&gt;parent-&gt;lchild==x)
#define isRChild(x) ((x)-&gt;parent&amp;&amp;(x)-&gt;parent-&gt;rchild==x)
#define hasLChild(x) ((x)-&gt;lchild)
#define hasRChild(x) ((x)-&gt;rchild)
#define hasChild(x) ((x)-&gt;lchild||(x)-&gt;rchild)
#define hasBothChild(x) ((x)-&gt;lchild&amp;&amp;(x)-&gt;rchild)
#define isLeaf(x) (!hasChild(x))
</span>
<span class="cp">#define stature(x) ((x)?x-&gt;height:-1)//与空树高度为-1的语义相吻合
#define balanceFac(x) (stature((x)-&gt;lchild)-stature((x)-&gt;rchild))
#define isAvlBalanced(x) (-1&lt;=balanceFac(x)&amp;&amp;balanceFac(x)&lt;=1)
</span>
<span class="c1">//获得左右孩子中较高者，如果同高，则与父节点同侧者优先
</span><span class="cp">#define tallerChild(x) (\
	stature((x)-&gt;lchild)&gt;stature((x)-&gt;rchild)?((x)-&gt;lchild):(\
	stature((x)-&gt;rchild)&gt;stature((x)-&gt;lchild)?((x)-&gt;rchild):(\
	isLChild(x)?((x)-&gt;rchild):((x)-&gt;lchild)\
	)\
	)\
)
#define uncle(x)(\
	isLChild((x)-&gt;parent)?\
	((x)-&gt;parent-&gt;parent-&gt;rchild):\
	((x)-&gt;parent-&gt;parent-&gt;lchild)\
)
#define sibling(x)(isLChild(x)?(x)-&gt;parent-&gt;rchild:(x)-&gt;parent-&gt;lchild)
</span><span class="c1">//获得x的父节点到其的链接，若其为根，则返回根节点，用于更新链接，而碎语原来不存在的链接，不可用，比如BST的插入新节点的新建链接时，可用于AVL树和红黑树的动态调整的递归当中
</span><span class="cp">#define fromParentTo(x) (isRoot(x)?_root:(isLChild(x)?(x)-&gt;parent-&gt;lchild:(x)-&gt;parent-&gt;rchild))
</span><span class="c1">//红黑树专用
</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">RB_RED</span><span class="p">,</span> <span class="n">RB_BLACK</span> <span class="p">}</span> <span class="n">RBColor</span><span class="p">;</span><span class="c1">//节点颜色
</span><span class="cp">#define isBlack(x) (!(x)||((x)-&gt;color==RB_BLACK))//空节点只能在最底层，定义为黑节点
#define isRed(x) (!isBlack(x))
</span><span class="c1">//注意下面这个注释和\的位置，\必须放在最后，否则就报错了
</span><span class="cp">#define BlackHeightUpdated(x) (</span><span class="cm">/*红黑树高度更新条件*/</span><span class="cp">\
	stature(x-&gt;lchild)==stature(x-&gt;rchild) &amp;&amp;\
	x-&gt;height==(isRed(x)?stature(x-&gt;lchild):stature(x-&gt;rchild)+1)\
)
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">BinTreeNode</span> <span class="p">{</span>
	<span class="c1">//节点数据
</span>	<span class="n">T</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span> <span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">height</span><span class="p">;</span><span class="c1">//通用,教材中规定仅含单个节点的树高度为0，空树高度为-1
</span>	<span class="n">RBColor</span> <span class="n">color</span><span class="p">;</span>

	<span class="c1">//构造函数
</span>	<span class="n">BinTreeNode</span><span class="p">()</span> <span class="o">:</span><span class="n">parent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">lchild</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">rchild</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">color</span><span class="p">(</span><span class="n">RB_RED</span><span class="p">)</span> <span class="p">{}</span>

	<span class="n">BinTreeNode</span><span class="p">(</span><span class="n">T</span> <span class="n">e</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RBColor</span> <span class="n">c</span> <span class="o">=</span> <span class="n">RB_RED</span><span class="p">)</span> <span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">lchild</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">rchild</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">color</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//操作接口
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsLC</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsRC</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">succ</span><span class="p">();</span><span class="c1">//当前节点的直接后继
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">VST</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">travIn</span><span class="p">(</span><span class="n">VST</span><span class="o">&amp;</span> <span class="n">visit</span><span class="p">)</span> <span class="p">{</span> <span class="n">travIn_R</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span> <span class="p">}</span><span class="c1">//操作器，recursion递归
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">VST</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">travPre</span><span class="p">(</span><span class="n">VST</span><span class="o">&amp;</span> <span class="n">visit</span><span class="p">)</span> <span class="p">{</span> <span class="n">travPre_R</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span> <span class="p">}</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">VST</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">travPost</span><span class="p">(</span><span class="n">VST</span><span class="o">&amp;</span> <span class="n">visit</span><span class="p">)</span> <span class="p">{</span> <span class="n">travPost_R</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span> <span class="p">}</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">VST</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">travLevel</span><span class="p">(</span><span class="n">VST</span><span class="o">&amp;</span> <span class="n">visit</span><span class="p">)</span> <span class="p">{</span> <span class="n">travLevel_R</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span> <span class="p">}</span>

	<span class="c1">//比较器、判等器
</span>	<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">btn</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span> <span class="o">&lt;</span> <span class="n">btn</span><span class="p">.</span><span class="n">data</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">bool</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">btn</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span> <span class="o">==</span> <span class="n">btn</span><span class="p">.</span><span class="n">data</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//接口实现
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insertAsLC</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">lchild</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insertAsRC</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">rchild</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//遍历算法
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">VST</span><span class="o">&gt;</span><span class="c1">//元素类型，操作器
</span><span class="kt">void</span> <span class="n">travIn_R</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">,</span> <span class="n">VST</span><span class="o">&amp;</span> <span class="n">visit</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span><span class="k">return</span><span class="p">;</span>
	<span class="n">travIn_R</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span>
	<span class="c1">//visit(x-&gt;data);
</span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" height:"</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="s">" color:(0红1黑)"</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">travIn_R</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//直接后继
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">succ</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rchild</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">rchild</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">==</span> <span class="n">x</span><span class="p">))</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="bintree">BinTree</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//基本二叉树
</span><span class="cp">#ifndef BINTREE_H
#define BINTREE_H
</span>
<span class="cp">#include"BinTreeNode.h"
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">BinTree</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_root</span><span class="p">;</span>
	<span class="c1">//虚函数强制要求派生类更新其对应好函数，更新节点x高度
</span>	<span class="k">virtual</span> <span class="kt">int</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">);</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">removeAt</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span> <span class="n">hot</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>

	<span class="kt">void</span> <span class="n">updateHeightAbove</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">);</span><span class="c1">//更新节点x及其祖先高度
</span>
	<span class="c1">//构造析构
</span>	<span class="n">BinTree</span><span class="p">()</span> <span class="o">:</span><span class="n">_size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_root</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>
	<span class="c1">//~BinTree(){if(0&lt;_size)remove(_root);}
</span>	<span class="c1">//int remove(BinTreeNode&lt;T&gt;* x){return 0;}//删除根为x的子树，返回该子树原来的规模
</span>

	<span class="kt">int</span> <span class="n">size</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">root</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_root</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">_root</span><span class="p">;</span> <span class="p">}</span>

	<span class="c1">//插入节点
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsRoot</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsLC</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">insertAsLC</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insertAsRC</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">insertAsRC</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">attachAsLC</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">,</span> <span class="n">BinTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">);</span><span class="c1">//tree作为x左子树接入
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">attachAsRC</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">,</span> <span class="n">BinTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">);</span><span class="c1">//tree作为x右子树接入
</span>
	<span class="c1">//遍历
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">VST</span><span class="o">&gt;</span><span class="c1">//操作器
</span>	<span class="kt">void</span> <span class="n">travIn</span><span class="p">(</span><span class="n">VST</span><span class="o">&amp;</span> <span class="n">visit</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">_root</span><span class="p">)</span> <span class="p">{</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">travIn</span><span class="p">(</span><span class="n">visit</span><span class="p">);</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">//更新包括x在内的以上节点，用其两个孩子节点的值来判断
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">BinTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">updateHeightAbove</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">updateHeight</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">BinTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">updateHeight</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hasBothChild</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">?</span>\
			<span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">:</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span><span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span><span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//返回值为被删除节点的接替者，hot是被删除节点的父节点，两者均可能为空
//这里的hot为引用型指针，因为要改变hot的值，如果不改变原指针的值的话不需要用引用型
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BinTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">removeAt</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span> <span class="n">hot</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span><span class="c1">//记录实际被摘除的节点初值为x
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">succ</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//记录被删除节点的继任者
</span>	<span class="c1">//书中没有考虑被删除节点的父节点与继任者链接的问题,书中也没有考虑到被删除节点是根节点的问题
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="p">{</span> <span class="n">succ</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span> <span class="n">fromParentTo</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span><span class="c1">//(hot-&gt;lchild==w?hot-&gt;lchild:hot-&gt;rchild)=x;//书上这里代码写错了，少写了一句，导致缺少链接
</span>	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> <span class="p">{</span> <span class="n">succ</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span> <span class="n">fromParentTo</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span><span class="c1">//(hot-&gt;lchild==w?hot-&gt;lchild:hot-&gt;rchild)=x;}
</span>	<span class="k">else</span> <span class="p">{</span><span class="c1">//左右子树均存在的情况下，用x的直接后继来替代x，因为其直接后继没有左孩子，就可以转化为简单的情况.
</span>		<span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">succ</span><span class="p">();</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">u</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span><span class="c1">//被删除节点的父亲，和hot相等
</span>		<span class="p">((</span><span class="n">u</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="o">?</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">:</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">succ</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//隔离要删除节点w
</span>	<span class="p">}</span>
	<span class="n">hot</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">succ</span><span class="p">)</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">hot</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">succ</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="binsearchtree">BinSearchTree</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//二叉搜索树
//重要算法：search、insert、remove
</span><span class="cp">#ifndef BINSEARCHTREE_H
#define BINSEARCHTREE_H
</span>
<span class="cp">#include"BinTree.h"
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">BinSearchTree</span> <span class="o">:</span><span class="k">public</span> <span class="n">BinTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_hot</span><span class="p">;</span><span class="c1">//search函数中最后访问的非空位置
</span><span class="nl">public:</span>
	<span class="c1">//虚函数强制要求派生类根据各自的规则对其重写
</span>	<span class="c1">//只有虚函数是动态绑定的，如果派生类需要重写基类函数，就要把这些函数声明为虚函数。
</span>	<span class="c1">//而声明中的非虚函数，通常代表那些不希望被派生类修改的功能。
</span>	<span class="k">virtual</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
	<span class="k">virtual</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
	<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>

	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">rotateAt</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">);</span><span class="c1">//节点变化统一算法，返回调整后局部子树根节点位置。注意子树会链接到上层节点，但是上层节点到局部子树根节点的链接要上层函数完成
</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">connect34</span><span class="p">(</span><span class="c1">//三四重构
</span>		<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">a</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">b</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">c</span><span class="p">,</span>
		<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">T0</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">T1</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">T2</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">T3</span>
	<span class="p">);</span>
<span class="p">};</span>

<span class="c1">//语义规定：搜索到就返回该节点的指针，否则返回搜索的最后一个节点的指针，即_hot
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BinSearchTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">searchIn</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">_hot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BinSearchTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_root</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span><span class="c1">//处理空树
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">_hot</span><span class="p">);</span><span class="c1">//以hot为父节点创建节点
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="n">_hot</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="n">_hot</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>	<span class="k">else</span> <span class="n">_hot</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span><span class="c1">//这一句书中没有，是一个大budge
</span>	<span class="n">_size</span><span class="o">++</span><span class="p">;</span>
	<span class="n">updateHeightAbove</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">BinSearchTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//要删除的节点不存在
</span>	<span class="n">removeAt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_hot</span><span class="p">);</span><span class="c1">//hot是x的父节点,若x为根节点，hot为空
</span>	<span class="n">_size</span><span class="o">--</span><span class="p">;</span>
	<span class="n">updateHeightAbove</span><span class="p">(</span><span class="n">_hot</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BinSearchTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">connect34</span><span class="p">(</span><span class="c1">//三四重构
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">a</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">b</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">c</span><span class="p">,</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">T0</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">T1</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">T2</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">T3</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">T0</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">T0</span><span class="p">)</span><span class="n">T0</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span><span class="c1">//这里别忘了if(T0),以为空指针没有父子节点等，会出现内存访问出错
</span>	<span class="n">a</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">T1</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">T1</span><span class="p">)</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">T2</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">T2</span><span class="p">)</span><span class="n">T2</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">T3</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">T3</span><span class="p">)</span><span class="n">T3</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BinSearchTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">rotateAt</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span><span class="c1">//v为非空的孙辈节点
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="c1">//视p，g不同的相对位置分四种情况讨论，分别是zigzig、zagzag、zigzag、zagzig
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">isLChild</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isLChild</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span><span class="c1">//向上链接，因为connect34函数并没有实现这个
</span>			<span class="k">return</span> <span class="n">connect34</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">connect34</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isLChild</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">connect34</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span><span class="c1">//这一句刚开始粗心写错了，调试过程中发现了,细心也很重要啊，这种错误估计也只能在调试中发现了
</span>		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">connect34</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//static函数与普通函数的区别：用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">static</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">searchIn</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span> <span class="n">hot</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span> <span class="o">||</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span><span class="k">return</span> <span class="n">v</span><span class="p">;</span><span class="c1">//在空指针处假想通配符
</span>	<span class="n">hot</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">searchIn</span><span class="p">((</span><span class="n">e</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">?</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">:</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">),</span> <span class="n">e</span><span class="p">,</span> <span class="n">hot</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//template&lt;typename T&gt;
</span><span class="k">static</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="avltree">AVLTree</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef AVLTREE_H
#define AVLTREE_H
</span><span class="c1">//适度平衡树：树高渐进意义上不超过logn
//AVL树：兄弟节点高度相差最多为1
//局部性特征:1)经过单次动态修改后，最多只有O(1)处局部不再满足条件；2)总可以在logn的时间内，使得这些局部重新满足条件
//重要算法：zig、zag（上下可变、左右不乱，子树高度变化不超过1）
</span><span class="cp">#include"BinSearchTree.h"
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">AVLTree</span> <span class="o">:</span><span class="k">public</span> <span class="n">BinSearchTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span><span class="c1">//重写insert函数
</span>	<span class="kt">bool</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span><span class="c1">//重写remove函数
</span>	<span class="c1">//search函数沿用
</span><span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">AVLTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_root</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span><span class="c1">//处理空树
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">_hot</span><span class="p">);</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="n">_hot</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="n">_hot</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>	<span class="k">else</span> <span class="n">_hot</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span><span class="c1">//这一句书中没有，是一个大budge
</span>	<span class="c1">//创建新节点后，其父节点高度可能变化，其祖父节点及以上可能失衡
</span>	<span class="k">for</span> <span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">g</span> <span class="o">=</span> <span class="n">_hot</span><span class="p">;</span> <span class="n">g</span><span class="p">;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span><span class="c1">//由父节点往上寻找失衡节点
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isAvlBalanced</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">//前往别忘了把重整后的子树的顶点链接到原父节点，因为rotate函数只是把涉及到的链接都做好了，而g的父节点不在其处理范围之内
</span>			<span class="n">fromParentTo</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">rotateAt</span><span class="p">(</span><span class="n">tallerChild</span><span class="p">(</span><span class="n">tallerChild</span><span class="p">(</span><span class="n">g</span><span class="p">)));</span><span class="c1">//调整失衡节点,rotate()在BinSearchTree中声明和实现
</span>			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">updateHeight</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">AVLTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">removeAt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_hot</span><span class="p">);</span> <span class="n">_size</span><span class="o">--</span><span class="p">;</span><span class="c1">//先按照BST的规则进行删除，然后在重新平衡
</span>	<span class="k">for</span> <span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">g</span> <span class="o">=</span> <span class="n">_hot</span><span class="p">;</span> <span class="n">g</span><span class="p">;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isAvlBalanced</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
			<span class="n">g</span> <span class="o">=</span> <span class="n">fromParentTo</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">rotateAt</span><span class="p">(</span><span class="n">tallerChild</span><span class="p">(</span><span class="n">tallerChild</span><span class="p">(</span><span class="n">g</span><span class="p">)));</span>
		<span class="n">updateHeight</span><span class="p">(</span><span class="n">g</span><span class="p">);</span><span class="c1">//应该意识到，即使g没有失衡，高度也可能降低
</span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="splaytree">SplayTree</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef SPLAYTREE_H
#define SPRAYTREE_H
</span><span class="c1">//AVL痛点：每次插入删除要调整，可以说AVL树是一个时时小心处处谨慎的人
//伸展树：利用局部性：刚刚访问过的元素，极有可能再次被访问.
//策略：节点一旦被访问，随即调整到树根。即逐层单旋，直到树根，但这种策略有最坏情况，即退化成单链的情况，这时候分摊复杂度也有O(n)\
//策略点睛：将单层伸展改为双层伸展，有四种情况，其中zigzag、zagzig，和AVL树双旋完全等效，采用自下而上两次单旋，zigzig、zagzag，有细微的差异，将从下而上的单旋改为从上而下的单旋，这个细微的差异将是颠覆性的
//折叠效果：一旦访问坏节点，对应路径长度至少减半，最坏情况不至于持续发生，此时的分摊复杂度为O(logn)
//关键算法：splay()将定点自下而上转移到根节点
//有了splay算法，search、insert、remove都非常方便
</span>
<span class="cp">#include"BinSearchTree.h"
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SplayTree</span> <span class="o">:</span><span class="k">public</span> <span class="n">BinSearchTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">splay</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">);</span><span class="c1">//将节点v移到树根
</span><span class="nl">public:</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span><span class="c1">//重写insert函数
</span>	<span class="kt">bool</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span><span class="c1">//重写remove函数
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span><span class="c1">//重写search函数
</span><span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">NodePosi</span><span class="o">&gt;</span><span class="kr">inline</span> <span class="kt">void</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">NodePosi</span> <span class="n">p</span><span class="p">,</span> <span class="n">NodePosi</span> <span class="n">lc</span><span class="p">)</span> <span class="p">{</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">lc</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="p">)</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">NodePosi</span><span class="o">&gt;</span><span class="kr">inline</span> <span class="kt">void</span> <span class="n">attachAsRChild</span><span class="p">(</span><span class="n">NodePosi</span> <span class="n">p</span><span class="p">,</span> <span class="n">NodePosi</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">SplayTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">splay</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">)</span><span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">gg</span><span class="p">;</span>
	<span class="c1">//用if-else判断四种情况实现双旋操作，与书中定义保持一致，zigzag指对p进行zig，对g进行zag，故先判断v节点，再判断p节点
</span>	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">gg</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isLChild</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isLChild</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span><span class="c1">//zigzig
</span>				<span class="n">attachAsLChild</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
				<span class="n">attachAsRChild</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span> <span class="n">attachAsRChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//zigzag
</span>				<span class="n">attachAsRChild</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
				<span class="n">attachAsRChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isLChild</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span><span class="c1">//zagzig
</span>				<span class="n">attachAsRChild</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
				<span class="n">attachAsRChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//zagzag
</span>				<span class="n">attachAsRChild</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span> <span class="n">attachAsRChild</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
				<span class="n">attachAsLChild</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">//将v与gg链接
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gg</span><span class="p">)</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">(</span><span class="n">gg</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">==</span> <span class="n">g</span><span class="p">)</span> <span class="o">?</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">gg</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">attachAsRChild</span><span class="p">(</span><span class="n">gg</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="n">updateHeight</span><span class="p">(</span><span class="n">g</span><span class="p">);</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="c1">//顺序不可颠倒
</span>	<span class="p">}</span><span class="c1">//伸展结束后，必有g=NULL，而p不一定
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span><span class="c1">//最后一步单旋
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">isLChild</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span> <span class="n">attachAsRChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span> <span class="n">attachAsRChild</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span> <span class="n">attachAsLChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="p">}</span>
		<span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">updateHeight</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">SplayTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">searchIn</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">_hot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">_root</span> <span class="o">=</span> <span class="n">splay</span><span class="p">((</span><span class="n">p</span> <span class="o">?</span> <span class="n">p</span> <span class="o">:</span> <span class="n">_hot</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">_root</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">SplayTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_root</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span><span class="c1">//处理空树
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span><span class="k">return</span> <span class="n">_root</span><span class="p">;</span><span class="c1">//要插入的节点已存在
</span>	<span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">updateHeightAbove</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">_root</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">SplayTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//要删除的节点不存在
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hasLChild</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span><span class="c1">//没有左子树直接删除
</span>		<span class="n">_root</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">_root</span><span class="p">)</span><span class="n">_root</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hasRChild</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span><span class="c1">//没有右子树直接删除
</span>		<span class="n">_root</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">_root</span><span class="p">)</span><span class="n">_root</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//左右子树存在，令根节点的直接后继作为新的根
</span>		<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">ltree</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
		<span class="n">ltree</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//暂时将左子树隔离
</span>		<span class="n">_root</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//只保留右子树
</span>		<span class="n">search</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="c1">//对右子树进行一个失败的查找，但右子树的最小定点此时一定在根节点，且其左子树必为空
</span>		<span class="n">_root</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">ltree</span><span class="p">;</span> <span class="n">ltree</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span><span class="c1">//将原左子树接回去
</span>	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_root</span><span class="p">)</span><span class="n">updateHeight</span><span class="p">(</span><span class="n">_root</span><span class="p">);</span>
	<span class="k">delete</span> <span class="n">t</span><span class="p">;</span> <span class="n">_size</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="redblacktree">RedBlackTree</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef REDBLACKTREE_H
#define REDBLACKTREE_H
</span><span class="c1">//适度平衡树：树高渐进意义上不超过logn
//红黑树：从树根到叶节点的通路总是包含一样多的黑点
//局部性特征:1)经过单次动态修改后，最多只有O(1)处局部不再满足条件；2)总可以在logn的时间内，使得这些局部重新满足条件
//红黑树动机：保存历史版本，利用各个版本之间的关联性，使得空间复杂度达到O(n+h*logn)而非O(n*h)，h表示历史版本树，n表示树的规模
//考察两个版本之间的差异，AVL树insert差异在O(1)remove是O(logn)，Spray树search、insert、remove都是O(logn)，B树insert是O(1)，remove是O(logn)，这种概率好像很小？
//红黑树可以保证两个版本之间的差异在O(1)
//根节点外部节点均为黑色，假想外部节点，即空节点
//红节点的父亲还是都是黑节点
//外部节点到根，途径的黑节点的个数是一致的
//红黑树的定义让人费解，更简单的理解是：利用提升变换（将每一个红节点提升一层），即得到了一颗（2,4）树，而每条路径黑节点的数目即为树高
//红黑树的插入删除等拓扑结构的变化不容易理解，所以，时时刻刻在脑海中有一个B树的影子方便理解，先想想变换前对应的B树，然后根据B树进行变化，然后在改为红黑树
//红黑树的每次insert和remove操作都只是常数次的结构调整和O(logn)的染色操作，这也是红黑树优于AVL树的主要方面
</span>
<span class="cp">#include"BinSearchTree.h"
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">RedBlackTree</span> <span class="o">:</span><span class="k">public</span> <span class="n">BinSearchTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="c1">//BinTreeNode&lt;T&gt;* search(const T&amp; e);//沿用search接口
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span><span class="c1">//重写insert接口
</span>	<span class="kt">bool</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span><span class="c1">//重写remove接口，以保证拓扑变换符合红黑树要求
</span><span class="nl">protected:</span>
	<span class="kt">int</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">);</span><span class="c1">//这里的高度定义为黑高度，只计算黑节点的高度
</span>	<span class="kt">void</span> <span class="n">solveDoubleBlack</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">);</span><span class="c1">//修复双黑节点的情况
</span>	<span class="kt">void</span> <span class="n">solveDoubleRed</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">);</span><span class="c1">//修复双红节点的情况
</span><span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">RedBlackTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">updateHeight</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">stature</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">),</span> <span class="n">stature</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isBlack</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">height</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//插入节点
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">RedBlackTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//处理空树
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_root</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RB_BLACK</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="n">x</span><span class="p">;</span><span class="c1">//插入节点已存在
</span>	<span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">_hot</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//注意这里红黑树的高度定义和BST不同，指的是黑高度
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="n">_hot</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="n">_hot</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>	<span class="k">else</span> <span class="n">_hot</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span><span class="c1">//这一句书中没有，是一个大budge。前面已经处理过空树，所以这里_hot必存在
</span>	<span class="n">_size</span><span class="o">++</span><span class="p">;</span>
	<span class="n">solveDoubleRed</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="c1">//返回插入的节点
</span>	<span class="k">return</span> <span class="n">x</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">_hot</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">RedBlackTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">solveDoubleRed</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//若递归至根节点，当然是RR-2这种情况才会向上递归，而此时根节点为红色，所以，应将其染黑，并且树高加1
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">isRoot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">height</span><span class="o">++</span><span class="p">;</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span><span class="c1">//插入节点后其父节点必存在
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">isBlack</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="k">return</span><span class="p">;</span><span class="c1">//无需调整
</span>	<span class="c1">//第一次插入时，x的uncle节点必为空（黑），但是当双红缺陷向上蔓延时，其uncle节点就不一定是黑节点了。
</span>	<span class="c1">//RR-1（uncle为黑节点），从（2,4）树的角度来看，其实节点数并没有超过限制，而是黑节点不再居中，调整黑节点居中即可，对x节点用34重构即可，然后重新染色，这种调整不会向上蔓延；RR-2节点数超过限制，应该分裂，具体的做法是逐层上升，但是可以发现，此时只需要染色，不需要拓扑变化
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span><span class="c1">//g必存在，且颜色为黑
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">u</span> <span class="o">=</span> <span class="n">uncle</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isBlack</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="p">{</span><span class="c1">//RR-1（uncle为黑节点）
</span>		<span class="c1">//先对各节点重新染色，然后34重构
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">isLChild</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">isLChild</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span>
		<span class="k">else</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span>
		<span class="n">g</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_RED</span><span class="p">;</span>
		<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">gg</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fromParentTo</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">rotateAt</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">gg</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//RR-2（uncle为红节点）
</span>		<span class="n">g</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_RED</span><span class="p">;</span><span class="c1">//书中在这里添加了判断g是否是根节点，其实不需要，因为该函数入口处已经对根节点的情况进行了处理
</span>		<span class="n">u</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">height</span><span class="o">++</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">height</span><span class="o">++</span><span class="p">;</span>
		<span class="n">solveDoubleRed</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">RedBlackTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//要删除元素不存在
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">r</span> <span class="o">=</span> <span class="n">removeAt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_hot</span><span class="p">);</span><span class="c1">//r为x的接替者
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">--</span><span class="n">_size</span><span class="p">))</span><span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//删除节点后为空树，可直接返回
</span>	<span class="c1">//_hot某一孩子刚被删除，且被r所指向节点（可能是NULL）替代，以下检查是否失衡
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_hot</span><span class="p">)</span> <span class="p">{</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">_root</span><span class="p">);</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span><span class="c1">//只有当x的左右孩子都存在的情况下，才会用其直接后继r与x交换数据，然后删除x，所以，书上这句是不需要的吧
</span>	<span class="c1">//以下分别判断三种情况，x、r的颜色
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">BlackHeightUpdated</span><span class="p">(</span><span class="n">_hot</span><span class="p">))</span><span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//x、r分别是红黑的情况，_hot的深度不变
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">isRed</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span><span class="c1">//x、r分别是黑红的情况，只需将r染黑
</span>	<span class="n">solveDoubleBlack</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//第三种情况，双黑缺陷
</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">RedBlackTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">solveDoubleBlack</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//根据24树的情况，大类分三种情况，1跟兄弟节点借；2跟父亲节点借；3合并
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span> <span class="o">?</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">:</span> <span class="n">_hot</span><span class="p">;</span><span class="c1">//父节点
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span><span class="k">return</span><span class="p">;</span><span class="c1">//处理退化到根节点的情况
</span>	<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="o">?</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">:</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span><span class="c1">//兄弟节点
</span>	<span class="c1">//递归基,下面这句是不对的，书上没有这句
</span>	<span class="c1">//但是书中考虑了退化到根节点的情况，应该写上
</span>	<span class="c1">//if(isRoot(v))return;
</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isBlack</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">t</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//s的红孩子，左孩子优先，没有时为NULL
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">isRed</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span><span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isRed</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">))</span><span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="c1">//跟兄弟节点借，即s为黑，且有红孩子
</span>			<span class="n">RBColor</span> <span class="n">oldColor</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">;</span>
			<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fromParentTo</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">rotateAt</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hasLChild</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span> <span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hasRChild</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span> <span class="p">}</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">oldColor</span><span class="p">;</span> <span class="n">updateHeight</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//s没有红孩子
</span>			<span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_RED</span><span class="p">;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">height</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isRed</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">height</span><span class="o">--</span><span class="p">;</span>
				<span class="n">solveDoubleBlack</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//兄弟s为红
</span>		<span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_BLACK</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RB_RED</span><span class="p">;</span>
		<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">isLChild</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">?</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">:</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
		<span class="n">_hot</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">fromParentTo</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">rotateAt</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">solveDoubleBlack</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="c1">//继续修正r处双黑，但是因为p已转红，修复的情况最多只有一步
</span>	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="btree">BTree</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BTREE_H
#define BTREE_H
</span>
<span class="c1">//BTree，多路平衡搜索树
//动机：系统存储容量的增长速度远远小于问题规模的增长速度，而内存的容量越大，访问速度就越慢
//高速缓存：1）不同容量的存储器，访问速度差异巨大，如果内存访问时1s，那么外存就要1day；2）从磁盘中读取1B，和读取1KB几乎一样快，以页或者块为单位，批量访问内存
//B树：1）不是二叉树，多叉树，所有底层节点的深度是一致的
//B树的目的是实现高速IO
//B是的每个节点是有两个向量，一个包含关键码，另一个包含指向下一个超级节点的指针
//m阶B树，内部节点的关键码的个数最大m-1，最大分支树m；最小关键码个数「m/2]
//关键算法：因插入而上溢之后采取的分裂处理；因删除而下溢之后采取的合并处理
</span>
<span class="c1">//快捷方式
</span><span class="cp">#define _mid (_order/2)//设置分裂时的中位数
#define _hi (_order)
#define _lo ((_order%2)?(_order/2):(_order/2-1))//设置关键码的上下界[lo,hi）
</span>

<span class="cp">#include"BTreeNode.h"
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">BTree</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">_size</span><span class="p">;</span><span class="c1">//存放的关键码总数，每一个超级节点是一个关键码
</span>	<span class="kt">int</span> <span class="n">_order</span><span class="p">;</span><span class="c1">//B树的阶数，一般不能修改
</span>	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_root</span><span class="p">;</span>
	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_hot</span><span class="p">;</span><span class="c1">//search接口最后访问的非空节点位置
</span>	<span class="c1">//BTree(){}
</span>	<span class="kt">void</span> <span class="n">solveOverflow</span><span class="p">(</span><span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">t</span><span class="p">);</span><span class="c1">//因插入而上溢之后采取的分裂处理
</span>	<span class="kt">void</span> <span class="n">solveUnderflow</span><span class="p">(</span><span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">t</span><span class="p">);</span><span class="c1">//；因删除而下溢之后采取的合并处理
</span><span class="nl">public:</span>
	<span class="n">BTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span> <span class="o">:</span><span class="n">_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="p">{</span> <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="p">}</span>
	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
	<span class="kt">bool</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">//查找接口实现
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span> <span class="n">_hot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//从根节点出发
</span>	<span class="k">while</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Rank</span> <span class="n">r</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span><span class="k">return</span> <span class="n">v</span><span class="p">;</span><span class="c1">//查找成功
</span>		<span class="k">else</span> <span class="p">{</span><span class="c1">//查找失败，继续深入一层
</span>			<span class="n">_hot</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span><span class="c1">//若查找到了根节点，意味着查找失败
</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//插入接口的实现
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">BTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">Rank</span> <span class="n">r</span> <span class="o">=</span> <span class="n">_hot</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="n">_hot</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">_hot</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">_size</span><span class="o">++</span><span class="p">;</span>
	<span class="n">solveOverflow</span><span class="p">(</span><span class="n">_hot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">_hot</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//删除接口的实现
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">BTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">Rank</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span><span class="c1">//说明x不在最底层，需要寻找该删除节点的直接后继，然后交换其位置，这样就能保证被删除节点在最后一层
</span>		<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">x</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
	<span class="n">_size</span><span class="o">--</span><span class="p">;</span>
	<span class="n">solveUnderflow</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//处理因插入而产生的上溢操作，此时，v是可能上溢的超级节点
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">BTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">solveOverflow</span><span class="p">(</span><span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span><span class="c1">//v代表当前节点，u代表其父节点,x代表新节点
</span>	<span class="c1">//已用宏定义的方式定义了_mid\_lo\_hi三个变量，设置分裂时的秩中位数_mid\关键码的上下界[lo,hi）
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">_hi</span><span class="p">)</span><span class="k">return</span><span class="p">;</span><span class="c1">//递归基
</span>	<span class="c1">//分裂节点
</span>	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">_mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">_mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">_mid</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_mid</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span> <span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span><span class="c1">//若分裂节点是根节点，这是B树高度增加的唯一情况
</span>		<span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">_mid</span><span class="p">],</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
		<span class="c1">//v-&gt;key.remove(_mid,_hi);v-&gt;child.remove(_mid+1,_hi+1);
</span>	<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//分裂节点不是根节点
</span>		<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">Rank</span> <span class="n">r</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">_mid</span><span class="p">]);</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">_mid</span><span class="p">]);</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
		<span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span><span class="c1">//别忘了这一句，x父节点指向u
</span>		<span class="n">solveOverflow</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">_mid</span><span class="p">,</span> <span class="n">_hi</span><span class="p">);</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">_mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//处理因删除而产生的下溢操作，此时，v是可能下溢的超级节点
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">BTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">solveUnderflow</span><span class="p">(</span><span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span><span class="c1">//v代表当前节点，u代表其父节点
</span>	<span class="c1">//已用宏定义的方式定义了_mid\_lo\_hi三个变量，设置分裂时的秩中位数_mid\关键码的上下界[lo,hi）
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span><span class="k">return</span><span class="p">;</span><span class="c1">//递归基：跟节点不存在下溢
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">_lo</span><span class="p">)</span><span class="k">return</span><span class="p">;</span><span class="c1">//递归基
</span>	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="c1">//存在下溢时，先左顾右盼，借不到元素再合并
</span>	<span class="n">Rank</span> <span class="n">r</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">BTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">;</span><span class="c1">//借元素或者合并的节点
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_lo</span><span class="p">))</span> <span class="p">{</span><span class="c1">//从左边借
</span>		<span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
		<span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
		<span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
	<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_lo</span><span class="p">))</span> <span class="p">{</span><span class="c1">//从右边借
</span>		<span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">//与左边合并		
</span>		<span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
		<span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
		<span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">delete</span> <span class="n">v</span><span class="p">;</span>
		<span class="c1">//需要合并的时候，应判断u是不是根节点且只有一个元素，这是B树高度降低的唯一情况
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">&amp;&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">_root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">delete</span> <span class="n">u</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">solveUnderflow</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//与右边合并
</span>		<span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">delete</span> <span class="n">x</span><span class="p">;</span>
		<span class="c1">//需要合并的时候，应判断u是不是根节点且只有一个元素，这是B树高度降低的唯一情况
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">&amp;&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">_root</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">delete</span> <span class="n">u</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="n">u</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">solveUnderflow</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="priority_queue">Priority_queue</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef PRIORITYQUEUE_H
#define PRIORITYQUEUE_H
</span><span class="c1">//优先级队列不是一种数据结构，而是ADT，这里主要做到用完全二叉堆实现优先级队列
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">PriorityQueue</span> <span class="p">{</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//按照优先级次序插入词条
</span>	<span class="k">virtual</span> <span class="n">T</span> <span class="n">getMax</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//获得优先级最高的词条
</span>	<span class="k">virtual</span> <span class="n">T</span> <span class="n">delMax</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//删除优先级最高的词条
</span><span class="p">};</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="completeheap">CompleteHeap</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef COMPLETEHEAP_H
#define COMPLETEHEAP_H
</span>
<span class="cp">#include"PriorityQueue.h"
#include"Vector.h"
</span>
<span class="c1">//完全二叉堆，逻辑上的二叉树，形式上的向量
//快捷方式
</span><span class="cp">#define parent(i) ((i-1)/2)
#define LChild(i) (2*i+1)
#define RChild(i) (2*i+2)
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span><span class="c1">//i及其两个孩子中的最大者
</span><span class="n">Rank</span> <span class="n">ProperParent</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">_elem</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">n</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RChild</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">RChild</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">_elem</span><span class="p">[</span><span class="n">LChild</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">_elem</span><span class="p">[</span><span class="n">LChild</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">LChild</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">_elem</span><span class="p">[</span><span class="n">RChild</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">RChild</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">LChild</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">LChild</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">LChild</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//插入删除操作如此简洁明了，其保证是堆序性，即孩子的优先级小于父亲，上滤和下滤都是为了维护堆序性
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">CompleteHeap</span> <span class="o">:</span><span class="k">public</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">public</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="n">Rank</span> <span class="n">percolateDown</span><span class="p">(</span><span class="n">Rank</span> <span class="n">n</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">i</span><span class="p">);</span><span class="c1">//下滤
</span>	<span class="n">Rank</span> <span class="n">percolateUp</span><span class="p">(</span><span class="n">Rank</span> <span class="n">i</span><span class="p">);</span><span class="c1">//上滤
</span>	<span class="kt">void</span> <span class="n">heapify</span><span class="p">(</span><span class="n">Rank</span> <span class="n">n</span><span class="p">);</span><span class="c1">//Floyd建堆
</span><span class="nl">public:</span>
	<span class="n">CompleteHeap</span><span class="p">()</span> <span class="o">:</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{}</span><span class="c1">//派生类的抽象函数要知道怎么写，不然就编译错了
</span>	<span class="n">CompleteHeap</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">copyFrom</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="n">heapify</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="p">}</span>
	<span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//按照优先级次序插入词条,先添加到最后一个，然后不断上升
</span>	<span class="n">T</span> <span class="n">getMax</span><span class="p">();</span><span class="c1">//获得优先级最高的词条
</span>	<span class="n">T</span> <span class="n">delMax</span><span class="p">();</span><span class="c1">//删除优先级最高的词条，先将头结点和最后一个节点交换位置，然后删除最后一个元素，在将首元素不断下降
</span><span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">CompleteHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">percolateUp</span><span class="p">(</span><span class="n">Rank</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Rank</span> <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="c1">//第一版上滤
</span>	<span class="k">while</span> <span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_elem</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_elem</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">//第二版上滤
</span>	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">CompleteHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">percolateUp</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Rank</span> <span class="n">CompleteHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">percolateDown</span><span class="p">(</span><span class="n">Rank</span> <span class="n">n</span><span class="p">,</span> <span class="n">Rank</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Rank</span> <span class="n">j</span><span class="p">;</span><span class="c1">//i及其两个孩子中最大者
</span>	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">ProperParent</span><span class="p">(</span><span class="n">_elem</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span> <span class="p">{</span> <span class="n">swap</span><span class="p">(</span><span class="n">_elem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_elem</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">CompleteHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">delMax</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">T</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">_elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_elem</span><span class="p">[</span><span class="o">--</span><span class="n">_size</span><span class="p">];</span>
	<span class="n">percolateDown</span><span class="p">(</span><span class="n">_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">CompleteHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">getMax</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_elem</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">CompleteHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">heapify</span><span class="p">(</span><span class="n">Rank</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="n">percolateDown</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="huffman">Huffman</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef HUFFMAN_H
#define HUFFMAN_H
</span>
<span class="cp">#include&lt;iostream&gt;
</span>
<span class="cp">#include "CompleteHeap.h"
#include "BinTree.h"
</span>
<span class="c1">//huffman编码的实现，构造最优前缀码的贪心算法
//变长的前缀码实现数据压缩，最优前缀码一定是满二叉树
//(1)哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。
//(2)算法以|C|个叶结点开始，执行|C|－1次的“合并”运算后产生最终所要求的树T。
//(3)假设编码字符集中每一字符c的频率是f(c)。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。一旦2棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的2棵树的频率之和，并将新树插入优先队列Q。经过n－1次的合并后，优先队列中只剩下一棵树，即所要求的树T。
</span>
<span class="c1">//统计文档字符频率信息
</span><span class="cp">#define N_CHAR (0x80-0x20)//只考虑可打印字符,0x20表示空格，0x7E是~，显示的是这之间的字符
</span>
<span class="kt">int</span><span class="o">*</span> <span class="nf">statistics</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">N_CHAR</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N_CHAR</span><span class="p">);</span><span class="c1">//清零
</span>	<span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
	<span class="c1">//FILE* fout=fopen("d:\\output.txt","w");
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%c"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">);)</span><span class="c1">//这里%c不读取空格和回车等非打印字符？
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//fputc(ch,fout);
</span>			<span class="n">freq</span><span class="p">[</span><span class="n">ch</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="c1">//cout&lt;&lt;ch;
</span>		<span class="p">}</span>
	<span class="c1">//for(int i=0;i&lt;N_CHAR;i++)printf("%c %d\n",i,freq[i]);
</span>	<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="c1">//fclose(fout);
</span>	<span class="k">return</span> <span class="n">freq</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//定义树节点数据，字符值和频率
</span><span class="k">struct</span> <span class="n">huffnode</span> <span class="p">{</span>
	<span class="n">huffnode</span><span class="p">(</span><span class="kt">char</span> <span class="n">cc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ff</span><span class="p">)</span> <span class="o">:</span><span class="n">c</span><span class="p">(</span><span class="n">cc</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">ff</span><span class="p">)</span> <span class="p">{}</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span> <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">huffnode</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">.</span><span class="n">f</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">huffnode</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">c</span><span class="p">;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">f</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">huffman</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//计算文件中各个字符的比率
</span>	<span class="kt">int</span><span class="o">*</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">statistics</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="c1">//用二叉堆编码树森林，二叉堆中保存各个森林的根节点
</span>	<span class="c1">//初始化，将所有频率非0的节点加入完全二叉堆
</span>	<span class="n">Vector</span><span class="o">&lt;</span><span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">huffnode</span><span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span><span class="c1">//由向量构建二叉堆
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_CHAR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">huffnode</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">BinTreeNode</span><span class="o">&lt;</span><span class="n">huffnode</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
			<span class="n">t</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h1 id="kmp">KMP</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//关键在于：利用模式串本身的特点，i不回溯，令j重新定位，然后接着比较
</span><span class="kt">int</span> <span class="n">KMP</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">){</span>
	<span class="kt">int</span>  <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="c1">//左侧-1秩设置哨兵，与任何字符串均匹配
</span>			<span class="p">{</span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">;}</span>
		<span class="k">else</span>
			<span class="n">j</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">;</span><span class="c1">//若匹配成功，则i，j相等，返回0；
</span><span class="p">}</span>

<span class="cm">/*构造next表
next[j]表示在区间[0,j)的最长匹配前后缀（必须是真前缀）的数目
用dp方法求next[j],由于在-1设置哨兵，基址设置为next[0]=-1，即在0处不匹配时，i,j均加一
*/</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">buildNext</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">P</span><span class="p">){</span><span class="c1">//构造模式串P的next表
</span>	<span class="kt">size_t</span> <span class="n">m</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">N</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">];</span><span class="c1">//next表
</span>	<span class="kt">int</span> <span class="n">t</span><span class="o">=</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//模式串指针
</span>	<span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">&gt;</span><span class="n">t</span><span class="o">||</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="p">]){</span><span class="c1">//匹配
</span>			<span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="n">t</span><span class="o">++</span><span class="p">;</span>
			<span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="n">N</span><span class="p">[</span><span class="n">t</span><span class="p">]);</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">t</span><span class="o">=</span><span class="n">N</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">N</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//BM算法主体框架
</span><span class="kt">int</span> <span class="n">match</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span> <span class="n">T</span><span class="p">){</span><span class="c1">//兼容bad character和good suffix
</span>	<span class="kt">int</span><span class="o">*</span> <span class="n">bc</span><span class="o">=</span><span class="n">buildBC</span><span class="p">(</span><span class="n">P</span><span class="p">);</span><span class="kt">int</span><span class="o">*</span> <span class="n">gs</span><span class="o">=</span><span class="n">buildGS</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">i</span><span class="o">+</span><span class="n">strlen</span><span class="p">(</span><span class="n">P</span><span class="p">)){</span>
		<span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">])</span><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">&gt;--</span><span class="n">j</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">&gt;</span><span class="n">j</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
		<span class="k">else</span> <span class="n">i</span><span class="o">+=</span><span class="n">max</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">j</span><span class="o">-</span><span class="n">bc</span><span class="p">[</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]]);</span>
	<span class="p">}</span>
	<span class="k">delete</span><span class="p">[]</span> <span class="n">gs</span><span class="p">;</span><span class="k">delete</span><span class="p">[]</span> <span class="n">bc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">buildBC</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">P</span><span class="p">){</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">bc</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">256</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="n">bc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">m</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="n">bc</span><span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">buildSS</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">P</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">P</span><span class="p">);</span><span class="kt">int</span><span class="o">*</span> <span class="n">ss</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
	<span class="n">ss</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">lo</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">hi</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">lo</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
		<span class="k">if</span><span class="p">((</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">j</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">hi</span><span class="o">+</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">j</span><span class="o">-</span><span class="n">lo</span><span class="p">))</span>
			<span class="n">ss</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">ss</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">hi</span><span class="o">+</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">else</span><span class="p">{</span>
			<span class="n">hi</span><span class="o">=</span><span class="n">j</span><span class="p">;</span><span class="n">lo</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="p">);</span>
			<span class="k">while</span><span class="p">((</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">lo</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span><span class="o">==</span><span class="n">P</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">hi</span><span class="o">+</span><span class="n">lo</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="n">lo</span><span class="o">--</span><span class="p">;</span>
			<span class="n">ss</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ss</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">buildGS</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">P</span><span class="p">){</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">ss</span><span class="o">=</span><span class="n">buildSS</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">m</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">P</span><span class="p">);</span><span class="kt">int</span><span class="o">*</span> <span class="n">gs</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="n">gs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">UINT_MAX</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">ss</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
			<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
				<span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="n">gs</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">ss</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">delete</span><span class="p">[]</span> <span class="n">ss</span><span class="p">;</span><span class="k">return</span> <span class="n">gs</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
  
	</div>
	<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <!--
  <%- list_categories(item.categories, {
      show_count: false,
      class: 'article-category',
      style: 'none',
      separator: '►'
  }) %>
  -->
  
  <a class="article-category-link" href="/categories/#algorithm">algorithm</a>
  
</div>


  <div class="article-tags">
  <!--
  <% var tags = [];
    item.tags.forEach(function(tag){
      tags.push('<a href="' + config.root + tag.path + '">' + tag.name + '</a>');
    }); %>-->
  <span></span> <!--<%- tags.join('') %>-->
  
  
  <a href="/tags/#DSA">DSA</a>
  
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://localhost:4000/algorithm/2018/05/03/cppSTL/" data-title="C++STL总结 | Dipper" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>
   
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/algorithm/2018/04/02/PATadvanced/" title="PAT甲级考试最后一题总结">
  <strong>上一篇：</strong><br/>
  <span>
  PAT甲级考试最后一题总结</span>
</a>
</div>


<div class="next">
<a href="/algorithm/2018/06/06/algorithm/"  title="算法笔记">
 <strong>下一篇：</strong><br/> 
 <span>算法笔记
</span>
</a>
</div>

</nav>

	

</div>  

      
      
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside toc-content">
 
 <!--<%- toc(item.content) %>-->
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/#reading-notes" title="reading-notes">reading-notes<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/#tools" title="tools">tools<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/#algorithm" title="algorithm">algorithm<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/#life" title="life">life<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/#design-pattern" title="design-pattern">design-pattern<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/#python-openCV" title="python-openCV">python-openCV<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/#python" title="python">python<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/#java" title="java">java<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/#aliyun" title="aliyun">aliyun<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/#deepLearning" title="deepLearning">deepLearning<sup>5</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/#读书" title="读书">读书<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/#markdown" title="markdown">markdown<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#DSA" title="DSA">DSA<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/#效率" title="效率">效率<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/#design-pattern" title="design-pattern">design-pattern<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#openCV" title="openCV">openCV<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/#python" title="python">python<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/#LaTex" title="LaTex">LaTex<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#爬虫" title="爬虫">爬虫<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#java" title="java">java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#spring" title="spring">spring<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#数字图像处理" title="数字图像处理">数字图像处理<sup>2</sup></a></li>
			
		
		</ul>
</div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div id="tagcloud" class="tagcloudlist clearfix">
    </div>
  </div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            <a href="https://blog.csdn.net/qq_20633793" target="_blank" title="我的CSDN">我的CSDN</a>
          </li>
        
          <li>
            <a href="http://47.93.52.194" target="_blank" title="我的WordPress">我的WordPress</a>
          </li>
        
    </ul>
</div>

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="jiangxiaohe" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
</div>



</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I'm Dipper. <br/>
			This is my blog. Happy to meet you.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/jiangxiaohe" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:ni-ys13@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
	<!--
			<%  Array.prototype.S=String.fromCharCode(2);
			  Array.prototype.in_array=function(e){
    			var r=new RegExp(this.S+e+this.S);
    			return (r.test(this.S+this.join(this.S)+this.S));
				};
				var cc = new Array('by','by-nc','by-nc-nd','by-nc-sa','by-nd','by-sa','zero'); %>
		<% if (cc.in_array(theme.creative_commons) ) { %>
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/<%= theme.creative_commons %>/4.0" class="cc-opacity" target="_blank">
            <img src="<%- config.root %>img/cc-<%= theme.creative_commons %>.svg" alt="Creative Commons" />
          </a>
        </div>
    <% } %>
				-->

		<p class="copyright">
		Powered by <a href="http://jekyllrb.com" target="_blank" title="jekyll">jekyll</a> and Theme by <a href="https://github.com/simpleyyt/jekyll-jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="about" target="_blank" title="Dipper">Dipper</a>
		
		
		</p>
</div>
</footer>
    <script src="/assets/js/jquery-2.0.3.min.js"></script>
<script src="/assets/js/jquery.imagesloaded.min.js"></script>
<script src="/assets/js/gallery.js"></script>
<script src="/assets/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="/assets/js/toc.js"></script>

<script type="text/javascript">
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });

  
        getSize();
        if (myWidth >= 1024) {
          c.click();
          $('#toc.toc-aside').show();
        }
  

  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
      
    }
  });
});
</script>


<script src="/assets/js/tagcloud.js"></script>
<script>
$(document).ready(function() {
  var tags = [
    
    { "name": "读书", "path": "/tags/#读书", "length": 5 },
    
    { "name": "markdown", "path": "/tags/#markdown", "length": 1 },
    
    { "name": "DSA", "path": "/tags/#DSA", "length": 10 },
    
    { "name": "效率", "path": "/tags/#效率", "length": 6 },
    
    { "name": "design-pattern", "path": "/tags/#design-pattern", "length": 2 },
    
    { "name": "openCV", "path": "/tags/#openCV", "length": 8 },
    
    { "name": "python", "path": "/tags/#python", "length": 7 },
    
    { "name": "LaTex", "path": "/tags/#LaTex", "length": 1 },
    
    { "name": "爬虫", "path": "/tags/#爬虫", "length": 3 },
    
    { "name": "java", "path": "/tags/#java", "length": 1 },
    
    { "name": "spring", "path": "/tags/#spring", "length": 1 },
    
    { "name": "数字图像处理", "path": "/tags/#数字图像处理", "length": 2 },
    
  ];
  $("#tagcloud").html(tagcloudHelper(tags));
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  $('#toc.toc-aside').toc({
    title: "文章目录",
    showEffect: "none"
  });
  $('#toc.toc-article').toc({
    title: "文章目录",
    showEffect: "show",
    showSpeed: 0
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
/*
  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      //$('.hoverqrcode').hide();
  });
  */
});
</script>






<!--

-->




<link rel="stylesheet" href="/assets/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/assets/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      if ($(this).hasClass('emoji')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>


<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/assets/img/scrollup.png"/></a>
	</div>
	<script src="/assets/js/totop.js"></script>


<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

